{
    "noir_version": "1.0.0-beta.14+077dd5ebf93b737c363f97491376681e88395bd0",
    "hash": "12863548910872288543",
    "abi": {
        "parameters": [
            {
                "name": "alice_priv_key",
                "type": {
                    "kind": "field"
                },
                "visibility": "private"
            },
            {
                "name": "bob_pub_key_x",
                "type": {
                    "kind": "field"
                },
                "visibility": "private"
            },
            {
                "name": "bob_pub_key_y",
                "type": {
                    "kind": "field"
                },
                "visibility": "private"
            },
            {
                "name": "order_id",
                "type": {
                    "kind": "field"
                },
                "visibility": "private"
            },
            {
                "name": "merkle_proof",
                "type": {
                    "kind": "array",
                    "length": 20,
                    "type": {
                        "kind": "field"
                    }
                },
                "visibility": "private"
            },
            {
                "name": "is_even",
                "type": {
                    "kind": "array",
                    "length": 20,
                    "type": {
                        "kind": "boolean"
                    }
                },
                "visibility": "private"
            },
            {
                "name": "hash_lock_nonce",
                "type": {
                    "kind": "field"
                },
                "visibility": "public"
            },
            {
                "name": "nullifier_hash",
                "type": {
                    "kind": "field"
                },
                "visibility": "public"
            },
            {
                "name": "root",
                "type": {
                    "kind": "field"
                },
                "visibility": "public"
            }
        ],
        "return_type": null,
        "error_types": {
            "4703047920556725948": {
                "error_kind": "string",
                "string": "Field failed to decompose into specified 254 limbs"
            }
        }
    },
    "bytecode": "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",
    "debug_symbols": "td3fjiXJddjrd+G1Lioz1r/wqxwYAiXTBgGCEmjJwIGgdz/dvSM+UgeYgTxtX+2kOBN716pcnb9qFfH92+/+2x/+4V//x9//8c///Z/+5+/+y//zb7/7h7/88U9/+uP/+Ps//dM//v5f/vhPf/72f/23f/+7393/+Pf/8pc//OHb/+l3f/Pff/u3/vn3f/nDn//ld//lz//6pz/93e/+1+//9K8//qH/+c+///OP13/5/V++/bdff/e7P/z5v317/Xbgf//jn/7w/erf/+6v//bXL/+r1XP+5f4q/3r+x3//+eV/P5/n/Pv57r/+++9/+PffX/73o77yHBD19F9P2P/hhPXLJzz5rHPCt8v5pRN+7TPkfPkMX88vnZC/8hme7HvEt+t5f+mM+pUz3oh7xFt/PeHbl/SfPSHnzvKpr6+fPeGp33JC5eOEmt/0Gdbr+7nWbzmhe98Tep5fOuFXv581PsRTO37p+/n82o35fL0+x/O1fvHmfuKXD9kTfc7Yk/HbjljhiFq/5Yjn62u5v79d52+cR/7NPOqX5zG/8sX01z1j99/cof9bR6xxRORvO6J8V7rnp4+Y9ZuOmJW+sfH+xiP+em9k/vwR+6ePqN84i/nrLPbXbzpiP3fnv13+trtzx3JE/rYvZK/900d0OWKe33LEtyX/Wn9d+K/5jYf8J//U+PVDsv96SL2/6Y/A/+SfGvHzf2rEz/+pET//p0b8/J8a8fN/asTP/6kRP7/y8fMrHz+/8vHzKx8/v/Lxf2Ll4//Etv7qn+Vff/3GPu/PFv36xRPyV34w6tl3Gt8u5zcdsb/up/h2+Ytr8msn5P2uzt9+P/7jT2f5K8218t7f8Td/7FX9xwN+5Rv6vnPvzXd9vb94xK/H9F9bevI3fYpvf2jfT9Hr6xeP6F/9ocDd3fuXv5Bfuy/DbZnzWw749gOBSXzVL06ifuWOiG8/Jd/vaPzNbfns//wktofhs99fnMSvfIiJe1/vv/kx8/93W9bP3pb187dl/fxtWT9/W9bP35b1s7dl/fxt2T9/W9b/1dtyL220+5duy/7Z27J//rbsn78t++dvy/7527J/9rbsn78t5+dvy/6/elt++6uf52/+2uOXbsz51RvzznL9zSDy+c8fMHc14m9uy/+NA779Tdz9e96qXzygfnK3pn96t2Z+erd+9VP853Zrf/30bu3nJ3fr1w74T+7WXj+9W786iZ/fref969+71/NLu/WrJ/jJ6dtZ8R9O+K/f/tPv//GPf/kP/0+b371f3/7E+Lvfvc/n5f28rM9LfF7y81Kfl/68zOdl/3hZn1PW55T1OWV9TlmfU9bnlPU5ZX1OWZ9T1ueU+JwSn1Pic0p8TonPKfE5JT6nxOeU+JwSn1Pyc0p+TsnPKfk5JT+n5OeU/JySn1Pyc0p+TqnPKfU5pT6n1OeU+pxSn1Pqc0p9TqnPKfU5pT+n9OeU/pzSn1P6c0p/TunPKf05pT+n9OeU+Zwyn1Pmc8p8TpnPKfM5ZT6nzOeU+Zwyn1P255T9OWV/TtmfU/bnlP05ZX9O2Z9T9ueU/Tnl28/B5/U5r+95Xec1zmue1zqvfV7nvJ7znnPec857znnPOe855z3nvOec95zznnPec847N/Rz7ujn3NLPuaefc1M/565+zm39nPv6OTf2c+7s59zaz7m3n3NzP+fufs7t/Zz7+zk3+HPu8Ofc4s+5x59zkz/nLn/Obf6c+/w5N/pz7vTn3OrPudefc7M/525/zu3+nPv9OTf8c+7459zyz7nnn3PTP+euf85t/5z7/jk3/nPu/Ofc+s+5959z8z/n7n/O7f+c+/85C/CcDXjOCjxnB56zBM/ZgueswXP24DmL8JxNeM4qPGcXnrMMz9mG56zDc/bhOQvxnI14zko8ZyeesxTP2YrnrMVz9uI5i/GczXjOajxnN56zHM/Zjuesx3P24z378Z79eM9+vGc/3rMf79mP9+zHe/bjPfvxnv14n/sH9Dnv7Md79uM9+/Ge/XjPfrxnP96zH+/Zj/f+ge9P/HPe/TP//qF//9S/f+zfP/fvH/xnP96zH+/Zj3fdR8g57+zHe/bjPfvxnv14z368Zz/esx/v2Y/37Mcb95l0zjv78Z79eM9+vGc/3rMf79mP9+zHe/bjPfvx5n3InfPOfrxnP96zH+/Zj/fsx3v24z378Z79eM9+vHWfmue8sx/v2Y/37Md79uM9+/Ge/XjPfrxnP96zH+/3/Xi+vl/0vfh24nx/3Z/X7xvy4/U5/8D3FflcrHsR9yLvxT127rHfF2V/f92f1++L8uP1Oa/31H1P/b4q39/4+6r8eK3zeo/8viufi/25WN+35XPx/Phn1/d1+fG6zmvcfyDvRd2LvhdzLz4TWM/XeT2HPuejrmfdi3vsc4/9vjf7+2uf1zmvny9/vfeTvs+9eM9/s85rnNc8r/eDvveDvp/v1HrP51znc6575LofdN0Puu4HXefUdT7nOp9znc+57kjjftD4fKNWnM8Z53PG+Zxxv/S4H/T7Dn3/PHE+Z5zPmffIvB807wfN+0Ezzj+b57XO6/3i836X8n7S+txRq84HrfNB63zQul973U9a54uv88XX+eLrfJP6ftC+H7TP/dTnfurzMfseefdp3X1afT9o3w8699g5N9ScU+ecevdp3X1ad5/W3ad19mmdfVpnn9bZp3X3ad19Wmef1tmndfZp3X1ad5/W3ae4+xRfz734DDW+1nmN85rnte4/2Pfi892Ps01xtimee+Rdp7jrFE+cfyTPa53Xe+Yz9+J+0rtPcfcp3nvse499417kvTgHv31ez2d977HrHnt3KtbnexVrndfzWdc9c90JrPtp1/206/O9ivg6r895PUON+0njftI4E4jzQc9KRdwj437Su1SR59A8h+b5TuX5TuX9oHk/aPb5b+a8no95Firqfu11R1rni6/zxdf5mHWPrPu11/2gdT/oXaq4SxVnqeIsVZylirtUcZcq7lLFeUjFeUjFeUjFfUjFfUjFfUjFXaq4SxV3qeIuVcw5ds6x+xy777F3q+JuVex77L7Hnr2Kfb5X+xx6tyrvVuXdqjxblWer8mxVnq3Ku1V5tyrPVuXZqjxblXer8m5V3q3K5xz6nEPPIyrPIyrvUuVdqnzPoe9zXt/zeo+8G5V3o/I9h77n0HfO6+eeyrtQeRcqz0LlWag8C5V3ofIuVN6FynW++HW++DifM+6Zcb/4u1F5NyrvYyrvYyrjHnuXKuN82Pw6r895Pd+m+5TKvKeex1Sex1Rmn9d75H1KZd0B3K3Ku1VZ99j7pMr7pMo659Y5t84E7lbl3aq8W5Vnq/JsVZ6tyrtVebcq71Zln29Wn69/ztc/5+u/S5V3qXLOoXO+/jmf825Uzh3A3E+67ye9S5V3qXKfj3qeVHmeVLnvJ72PqryPqtyfj1pfX+f1Oa/veT2ftG751dmp+qrz2ud1zuv5oPV83YvP7V/Pe17Xeb1H3uqrp+5Fn39kzuvnTq37mKr7mKr7mKq7VPXG+WfzvNZ57fsPzL24H/WUX63zSc9O1e2+ut1Xd6vqblXdrar7mKrbfnWeU3WeU3WeU3XSr+5S1V2qOs+pOs+pOulX9zFV9zFVt/3qtl+dB1WdB1Xl+Ubl+Ubd9Ku7VHUeVHUeVHXKr0751V2ougtVdc485Ven/OqUX919qrtP1efMPmf2+ZR9PuVdp7rrVH2+9vOMqvOMqpt9dR9SdfepTvjVWac661T3CVV3n+ruU919qrtPdfep9vnun3Wqs051n1B196nuPtXdp9qfD9tfX+f1Oa/no/ZdqL4L1fdHqb5Pqb5PqT471V+fb1Q/X+f1Oa/31PuQ6vOQ6vOQ6vOQ6vOQ6vuQ6vuQ6vec+Z4zz89RfX6O6vuM6vuM6rNQfaqvT/X1Xae+D6m+D6m+P0n1Oqeu8znPz1F9fo7qu019t6nPQ6rPQ6rjTPQ+o/o+o/quU8c5NM6hcb74OOO829R3m/o8ofo8ofrsUp9d6ht9faOvzxOq83zxeT7mfT71fT71fT71Xac+2dcn+/o8nfpWX9/q67tP3ee7dNapzzr1Wafu+7Xffeo+X3yfL/48nPo8nPquU9916vNjVJ9t6rNNfYOv7zr1Xae+69R3nfquU+/zfTrb1Geb+gZf33Xqu05916lP8vXZpjnbNDf45q7T3HWau05z12m+6vxLfV7nvJ6POvcBNTf65jyh5jyh5vwgNfcBNfcBNfdHqbkLNXeh5j6j5mzUnI2as1Fz/mZi7kLN/auJOdU3p/rmVN+sr/N6P+jdpzn7NGef5uzTnH2au09z92nOD1FzHk5zHk5zHk5z12nuOs35IWrOw2nOw2lu783dp7n7NPfpNPfpNLf55qzUnMfTnMfTnJ+i5j6d5ibfnMfTnMfTnMfTnL+YmPt0mpt7cx5Pcx5Pcx5Pc/5iYu7TaW7tzdmnOfs05/E0fT7lfTrNjb05j6c5j6c5P0LNXae5T6e5tTdnoeY8nubU3tx1mrtOc9dpzl9LzPlridnnc+7zOe82zd2mOT8+zfnxac4uzf3xad8fn/bdpn23aZ+/5ttfcV7zvNb9B/pezL24x55n0z7Ppv2853Wd17j/YN6LOv9Nn9c5r5/v0r6LtG/s7bNJ+2zSPpu0z9/x7btI+7bePpu0zybts0l7nU95F2nf1Ntnk/bZpH02aZ+/4dt3kfbNvH2eTPs8mXa85/UeeTdp387b94enfX942neZ9l2mfZdp32Xad5n2XaZ9f4Da9wG17wNq39zbd6H2Xah9n1H7PqP2fUbt+4zad6n2Xap9/3Ji38fUvo+pfR9T+y7Wvou1vy/W91+E3t836+nvF3Ev8vtvXny/qHvx7eQ3vl98O/n7b7bs79v14+L7en0unnvx7eTv/3Ou/X2/PhffTv7+b3/fr++/iL6/L9jnor//esv3i7kX3w/+/l36vmGfi+f7b7B8v3jvxfr+O77fL+Je5L2oe9H3Yu7Ft5O//w+rvv+is6vv49g/rr4d/v33Cr7/jxY+X/W3q3D1/fzPP1efUXy76s8X/O1qXO179Xy5ely9rs5ovl2FqzOdb1fl6szn29W4OhP69v9T/nJ1ZvT9dzxcnSl9uwpX6apctatxZVbLrJZZLbNaZrXMapnVMqtlVsusllmFWYVZhVmFWYVZhVmFWYVZhVmFWaVZpVmlWaVZpVmlWaVZpVmlWaVZlVmVWZVZlVmVWZVZlVmVWZVZlVm1WbVZtVm1WbVZtVm1WbVZtVm1WY1ZjVmNWY1ZjVmNWY1ZjVmNWY1ZbbPaZrXNapvVNqttVtustllts9p3Vj9+CeNcPa5eV3dWP34Z41zdWf34hYxzdWf145cyztWd1Y9fzDhXd1Y/fjnjXN1Z/fgFjXOVrspVuxpXd1Y/flnjXN1Z/fiFjR+z+vErGz8m9OOXNs7VndWPX9z4Masfv7rx+crfcWVWy6yWWS2zWma1zGqZ1TKrZVbLrJZZhVmFWYVZhVmFWYVZhVmFWYVZhVmlWaVZpVmlWaVZpVmlWaVZpVmlWZVZlVmVWZVZlVmVWZVZlVmVWZVZtVm1WbVZtVm1WbVZtVm1WbVZtVmNWY1ZjVmNWY1ZjVmNWY1ZjVmNWW2z2ma1zWqb1TarbVbbrLZZbbPad1Y/fpnkXN1Z/fiFknN1Z/Xjl0rOVboqV+1qXN1Z/fgFk3N1Z/Xjl0x+zOrHr5n8mNCPXzQ5V3dWP37Z5Mesfvy6yY+v/McvnJyrO6sfv3Ryrh5Xr6s7qx+/fHKu7qx+/ALKubqz+vFLKOfKrJZZLbNaZrXMapnVMqtlVsusllktswqzCrMKswqzCrMKswqzCrMKswqzSrNKs0qzSrNKs0qzSrNKs0qzSrMqsyqzKrMqsyqzKrMqsyqzKrMqs2qzarNqs2qzarNqs2qzarNqs2qzGrMasxqzGrMasxqzGrMasxqzGrPaZrXNapvVNqttVtustllts9pmpduXbl+6fen2pduXbl+6fen2pduXbl+6fen2pduXbl+6fen2pduXbl+6fen2pduXbl+6fen2pduXbl+6fen2pduXbl+6fen2pduXbl+6fen2pduXbl+6fen2pduXbl+6fen2pduXbl+6fen2pduXbl+6fen2pduXbl+6fen2pduXbl+6fen2pduXbl+6fen2pduXbl+6fen2pduXbl+6fen2pduXbl+6fen2pduXbl+6fen2pduXbl+6fen2pduXbl+6fen2pduXbl+6fen2pduXbl+6fen2pduXbl+6fen2pdtDt4duD90euj10e+j20O2h20O3h24P3R66PXR76PbQ7aHbQ7eHbg/dHro9dHvo9tDtodtDt4duD90euj10e+j20O2h20O3h24P3R66PXR76PbQ7aHbQ7eHbg/dHro9dHvo9tDtodtDt4duD90euj10e+j20O2h20O3h24P3R66PXR76PbQ7aHbQ7eHbg/dHro9dHvo9tDtodtDt4duD90euj10e+j20O2h20O3h24P3R66PXR76PbQ7aHbQ7eHbg/dHro9dHvo9tDtodtDt4duD90euj11e+r21O2p21O3p25P3Z66PXV76vbU7anbU7enbk/dnro9dXvq9tTtqdtTt6duT92euj11e+r21O2p21O3p25P3Z66PXV76vbU7anbU7enbk/dnro9dXvq9tTtqdtTt6duT92euj11e+r21O2p21O3p25P3Z66PXV76vbU7anbU7enbk/dnro9dXvq9tTtqdtTt6duT92euj11e+r21O2p21O3p25P3Z66PXV76vbU7anbU7enbk/dnro9dXvq9tTtqdtTt6duT92euj11e+r21O2p20u3l24v3V66vXR76fbS7aXbS7eXbi/dXrq9dHvp9tLtpdtLt5duL91eur10e+n20u2l20u3l24v3V66vXR76fbS7aXbS7eXbi/dXrq9dHvp9tLtpdtLt5duL91eur10e+n20u2l20u3l24v3V66vXR76fbS7aXbS7eXbi/dXrq9dHvp9tLtpdtLt5duL91eur10e+n20u2l20u3l24v3V66vXR76fbS7aXbS7eXbi/dXrq9dHvp9tLtpdtLt5duL91eur10e+n20u2l20u3l24v3V66vXV76/bW7a3bW7e3bm/d3rq9dXvr9tbtrdtbt7dub93eur11e+v21u2t21u3t25v3d66vXV76/bW7a3bW7e3bm/d3rq9dXvr9tbtrdtbt7dub93eur11e+v21u2t21u3t25v3d66vXV76/bW7a3bW7e3bm/d3rq9dXvr9tbtrdtbt7dub93eur11e+v21u2t21u3t25v3d66vXV76/bW7a3bW7e3bm/d3rq9dXvr9tbtrdtbt7dub93eur11e+v21u2t21u3t25v3d66vXV76/bW7a3bR7ePbh/dPrp9dPvo9tHto9tHt49uH90+un10++j20e2j20e3j24f3T66fXT76PbR7aPbR7ePbh/dPrp9dPvo9tHto9tHt49uH90+un10++j20e2j20e3j24f3T66fXT76PbR7aPbR7ePbh/dPrp9dPvo9tHto9tHt49uH90+un10++j20e2j20e3j24f3T66fXT76PbR7aPbR7ePbh/dPrp9dPvo9tHto9tHt49uH90+un10++j20e2j20e3j24f3T66fXT76PbR7aPbR7ePbh/dPrp96/at27du37p96/at27du37p96/at27du37p96/at27du37p96/at27du37p96/at27du37p96/at27du37p96/at27du37p96/at27du37p96/at27du37p96/at27du37p96/at27du37p96/at27du37p96/at27du37p96/at27du37p96/at27du37p96/at27du37p96/at27du37p96/at27du37p96/at27du37p96/at27du37p96/at27du37p96/at27du37p96/at27du37p96/at27du37fb36/b7e/X7fb363b7+3W7/f263f5+3W5/v263v1+329+v2+3v1+329+t2+/t1u/39ut3+ft1uf79ut79ft9vfr9vt79ft9vfrdvv7dbv9/brd/n7dbn+/bre/X7fb36/b7e/X7fb363b7+3W7/f263f5+vWa1zGqZ1TKrZVbLrJZZLbNaZrXMaplVmFWYVZhVmFWYVZhVmFWYVZhVmFWaVZpVmlWaVZpVmlWaVZpVmlWaVZlVmVWZVZlVmVWZVZlVmVWZVZlVm1WbVZtVm1WbVZtVm1WbVZtVm9WY1ZjVmNWY1ZjVmNWY1ZjVmNWY1TarbVbbrLZZbbPaZrXNapvVNqvb7e9zu/19bre/z+3297nd/j6329/ndvv73G5/n9vt73O7/X1ut7/P7fb3ud3+Prfb3+d2+/vcbn+f2+3vc7v9fW63v8/t9ve53f4+t9vf53b7+9xuf5/b7e9zu/19bre/z+3297nd/j6329/nNatlVsusllkts1pmtcxqmdUyq2VWy6zCrMKswqzCrMKswqzCrMKswqzCrNKs0qzSrNKs0qzSrNKs0qzSrNKsyqzKrMqsyqzKrMqsyqzKrMqsyqzarNqs2qzarNqs2qzarNqs2qzarMasxqzGrMasxqzGrMasxqzGrMastllts9pmtc1qm9U2q21W26y2Wd1uf9/b7e97u/19b7e/7+32973d/r6329/3dvv73m5/39vt73u7/X1vt7/v7fb3vd3+vrfb3/d2+/vebn/f2+3ve7v9fW+3v+/t9ve93f6+t9vf93b7+95uf9/b7e97u/19b7e/7+32973d/r6vWS2zWma1zGqZ1TKrZVbLrJZZLbNaZhVmFWYVZhVmFWYVZhVmFWYVZhVmlWaVZpVmlWaVZpVmlWaVZpVmlWZVZlVmVWZVZlVmVWZVZlVmVWZVZtVm1WbVZtVm1WbVZtVm1WbVZtVmNWY1ZjVmNWY1ZjVmNWY1ZjVmNWa1zWqb1TarbVbbrLZZbbPaZrXNSrcv3b50+9LtS7cv3b50+9LtS7cv3b50+9LtS7cv3b50+9LtS7cv3b50+9LtS7cv3b50+9LtS7cv3b50+9LtS7cv3b50+9LtS7cv3b50+9LtS7cv3b50+9LtS7cv3b50+9LtS7cv3b50+9LtS7cv3b50+9LtS7cv3b50+9LtS7cv3b50+9LtS7cv3b50+9LtS7cv3b50+9LtS7cv3b50+9LtS7cv3b50+9LtS7cv3b50+9LtS7cv3b50+9LtS7cv3b50+9LtS7cv3b50+9LtS7cv3b50+9LtS7cv3b50+9LtS7eHbg/dHro9dHvo9tDtodtDt4duD90euj10e+j20O2h20O3h24P3R66PXR76PbQ7aHbQ7eHbg/dHro9dHvo9tDtodtDt4duD90euj10e+j20O2h20O3h24P3R66PXR76PbQ7aHbQ7eHbg/dHro9dHvo9tDtodtDt4duD90euj10e+j20O2h20O3h24P3R66PXR76PbQ7aHbQ7eHbg/dHro9dHvo9tDtodtDt4duD90euj10e+j20O2h20O3h24P3R66PXR76PbQ7aHbQ7eHbg/dHro9dHvq9tTtqdtTt6duT92euj11e+r21O2p21O3p25P3Z66PXV76vbU7anbU7enbk/dnro9dXvq9tTtqdtTt6duT92euj11e+r21O2p21O3p25P3Z66PXV76vbU7anbU7enbk/dnro9dXvq9tTtqdtTt6duT92euj11e+r21O2p21O3p25P3Z66PXV76vbU7anbU7enbk/dnro9dXvq9tTtqdtTt6duT92euj11e+r21O2p21O3p25P3Z66PXV76vbU7anbU7enbk/dnro9dXvq9tTtqdtTt5duL91eur10e+n20u2l20u3l24v3V66vXR76fbS7aXbS7eXbi/dXrq9dHvp9tLtpdtLt5duL91eur10e+n20u2l20u3l24v3V66vXR76fbS7aXbS7eXbi/dXrq9dHvp9tLtpdtLt5duL91eur10e+n20u2l20u3l24v3V66vXR76fbS7aXbS7eXbi/dXrq9dHvp9tLtpdtLt5duL91eur10e+n20u2l20u3l24v3V66vXR76fbS7aXbS7eXbi/dXrq9dHvp9tLtpdtLt5duL91eur10e+v21u2t21u3t25v3d66vXV76/bW7a3bW7e3bm/d3rq9dXvr9tbtrdtbt7dub93eur11e+v21u2t21u3t25v3d66vXV76/bW7a3bW7e3bm/d3rq9dXvr9tbtrdtbt7dub93eur11e+v21u2t21u3t25v3d66vXV76/bW7a3bW7e3bm/d3rq9dXvr9tbtrdtbt7dub93eur11e+v21u2t21u3t25v3d66vXV76/bW7a3bW7e3bm/d3rq9dXvr9tbtrdtbt7dub93eur11e+v21u2t21u3j24f3T66fXT76PbR7aPbR7ePbh/dPrp9dPvo9tHto9tHt49uH90+un10++j20e2j20e3j24f3T66fXT76PbR7aPbR7ePbh/dPrp9dPvo9tHto9tHt49uH90+un10++j20e2j20e3j24f3T66fXT76PbR7aPbR7ePbh/dPrp9dPvo9tHto9tHt49uH90+un10++j20e2j20e3j24f3T66fXT76PbR7aPbR7ePbh/dPrp9dPvo9tHto9tHt49uH90+un10++j20e2j20e3j24f3T66fXT71u1bt2/dvnX71u1bt2/dvnX71u1bt2/dvnX71u1bt2/dvnX71u1bt2/dvnX71u1bt2/dvnX71u1bt2/dvnX71u1bt2/dvnX71u1bt2/dvnX71u1bt2/dvnX71u1bt2/dvnX71u1bt2/dvnX71u1bt2/dvnX71u1bt2/dvnX71u1bt2/dvnX71u1bt2/dvnX71u1bt2/dvnX71u1bt2/dvnX71u1bt2/dvnX71u1bt2/dvnX71u1bt2/dvnX71u1bt2/dvnX71u1bt2/dvnX71u1bt2/dvnX71u1bt2/dvm+3r6/b7evrdvv6ut2+vm63r6/b7evrdvv6ut2+vm63r6/b7evrdvv6ut2+vm63r6/b7evrdvv6ut2+vm63r6/b7evrdvv6ut2+vm63r6/b7evrdvv6ut2+vm63r6/b7evrdvv6ut2+vm63r6/b7evrNatlVsusllkts1pmtcxqmdUyq2VWy6zCrMKswqzCrMKswqzCrMKswqzCrNKs0qzSrNKs0qzSrNKs0qzSrNKsyqzKrMqsyqzKrMqsyqzKrMqsyqzarNqs2qzarNqs2qzarNqs2qzarMasxqzGrMasxqzGrMasxqzGrMastllts9pmtc1qm9U2q21W26y2Wd1uX8/t9vXcbl/P7fb13G5fz+329dxuX8/t9vXcbl/P7fb13G5fz+329dxuX8/t9vXcbl/P7fb13G5fz+329dxuX8/t9vXcbl/P7fb13G5fz+329dxuX8/t9vXcbl/P7fb13G5fz+329bxmtcxqmdUyq2VWy6yWWS2zWma1zGqZVZhVmFWYVZhVmFWYVZhVmFWYVZhVmlWaVZpVmlWaVZpVmlWaVZpVmlWZVZlVmVWZVZlVmVWZVZlVmVWZVZtVm1WbVZtVm1WbVZtVm1WbVZvVmNWY1ZjVmNWY1ZjVmNWY1ZjVmNU2q21W26y2WW2z2ma1zWqb1Tar2+3rvd2+3tvt673dvt7b7eu93b7e2+3rvd2+3tvt673dvt7b7eu93b7e2+3rvd2+3tvt673dvt7b7eu93b7e2+3rvd2+3tvt673dvt7b7eu93b7e2+3rvd2+3tvt673dvt7b7eu93b7e16yWWS2zWma1zGqZ1TKrZVbLrJZZLbMKswqzCrMKswqzCrMKswqzCrMKs0qzSrNKs0qzSrNKs0qzSrNKs0qzKrMqsyqzKrMqsyqzKrMqsyqzKrNqs2qzarNqs2qzarNqs2qzarNqsxqzGrMasxqzGrMasxqzGrMasxqz2ma1zWqb1TarbVbbrLZZbbPaZqXbl25fun3p9qXbl25fun3p9qXbl25fun3p9qXbl25fun3p9qXbl25fun3p9qXbl25fun3p9qXbl25fun3p9qXbl25fun3p9qXbl25fun3p9qXbl25fun3p9qXbl25fun3p9qXbl25fun3p9qXbl25fun3p9qXbl25fun3p9qXbl25fun3p9qXbl25fun3p9qXbl25fun3p9qXbl25fun3p9qXbl25fun3p9qXbl25fun3p9qXbl25fun3p9qXbl25fun3p9qXbl25fun3p9qXbl25fun3p9qXbl25fun3p9qXbQ7eHbg/dHro9dHvo9tDtodtDt4duD90euj10e+j20O2h20O3h24P3R66PXR76PbQ7aHbQ7eHbg/dHro9dHvo9tDtodtDt4duD90euj10e+j20O2h20O3h24P3R66PXR76PbQ7aHbQ7eHbg/dHro9dHvo9tDtodtDt4duD90euj10e+j20O2h20O3h24P3R66PXR76PbQ7aHbQ7eHbg/dHro9dHvo9tDtodtDt4duD90euj10e+j20O2h20O3h24P3R66PXR76PbQ7aHbQ7eHbg/dHro9dXvq9tTtqdtTt6duT92euj11e+r21O2p21O3p25P3Z66PXV76vbU7anbU7enbk/dnro9dXvq9tTtqdtTt6duT92euj11e+r21O2p21O3p25P3Z66PXV76vbU7anbU7enbk/dnro9dXvq9tTtqdtTt6duT92euj11e+r21O2p21O3p25P3Z66PXV76vbU7anbU7enbk/dnro9dXvq9tTtqdtTt6duT92euj11e+r21O2p21O3p25P3Z66PXV76vbU7anbU7enbk/dnro9dXvq9tTtqdtLt5duL91eur10e+n20u2l20u3l24v3V66vXR76fbS7aXbS7eXbi/dXrq9dHvp9tLtpdtLt5duL91eur10e+n20u2l20u3l24v3V66vXR76fbS7aXbS7eXbi/dXrq9dHvp9tLtpdtLt5duL91eur10e+n20u2l20u3l24v3V66vXR76fbS7aXbS7eXbi/dXrq9dHvp9tLtpdtLt5duL91eur10e+n20u2l20u3l24v3V66vXR76fbS7aXbS7eXbi/dXrq9dHvp9tLtpdtLt5duL91eur11e+v21u2t21u3t25v3d66vXV76/bW7a3bW7e3bm/d3rq9dXvr9tbtrdtbt7dub93eur11e+v21u2t21u3t25v3d66vXV76/bW7a3bW7e3bm/d3rq9dXvr9tbtrdtbt7dub93eur11e+v21u2t21u3t25v3d66vXV76/bW7a3bW7e3bm/d3rq9dXvr9tbtrdtbt7dub93eur11e+v21u2t21u3t25v3d66vXV76/bW7a3bW7e3bm/d3rq9dXvr9tbtrdtbt7dub93eur11e+v21u2t20e3j24f3T66fXT76PbR7aPbR7ePbh/dPrp9dPvo9tHto9tHt49uH90+un10++j20e2j20e3j24f3T66fXT76PbR7aPbR7ePbh/dPrp9dPvo9tHto9tHt49uH90+un10++j20e2j20e3j24f3T66fXT76PbR7aPbR7ePbh/dPrp9dPvo9tHto9tHt49uH90+un10++j20e2j20e3j24f3T66fXT76PbR7aPbR7ePbh/dPrp9dPvo9tHto9tHt49uH90+un10++j20e2j20e3j24f3T66fev2rdu3bt+6fev2rdu3bt+6fev2rdu3bt+6fev2rdu3bt+6fev2rdu3bt+6fev2rdu3bt+6fev2rdu3bt+6fev2rdu3bt+6fev2rdu3bt+6fev2rdu3bt+6fev2rdu3bt+6fev2rdu3bt+6fev2rdu3bt+6fev2rdu3bt+6fev2rdu3bt+6fev2rdu3bt+6fev2rdu3bt+6fev2rdu3bt+6fev2rdu3bt+6fev2rdvJqAuNutioC466tm7Ho66t2wmpC5G6GKkLkrooqQuTujipC5S6SKkLlbpYqQuWumipC5e6eKnBSw1eavBSg5cavNTgpQYvNXipwUsNXmrwUoOXGrzU4KUGLzV4qcFLDV5q8FKDlxq81OClBi81eKnBSw1eavBSg5cavNTgpQYvNXipwUsNXmrwUoOXGrzU4KUGLzV4qcFLDV5q8FKDlxq81OClBi81eKnBSw1eavBSg5cavNTgpQYvNXipwUsNXmrwUoOXGrzU4KUGLzV4qcFLDV5q8FKDlxq81OClBi81eKnBSw1eavBSg5cavNTgpQYvNXipwUsNXmrwUoOXGrzU4KUGLzV4qcFLDV5q8FKDlxq81OClBi81eKnBSw1eavBSg5cavNTgpQYvNXipwUsNXmrwUoOXGrzU4KUGLzV4qcFLDV5q8FKDlxq81OClBi81eKnBSw1eavBSg5cavNTgpQYvNXipwUsNXmrwUoOXGrzU4KUGLzV4qcFLDV5q8FKDlxq81OClBi81eKnBSw1eavBSg5cavNTgpQYvNXipwUsNXmrwUoOXGrzU4KUGLzV4qcFLDV5q8FKDlxq81OClBi81eKnBSw1eavBSg5cavNTgpQYvNXipwUsNXmrwUoOXGrzU4KUGLzV4qcFLDV5q8FKDlxq81OClBi81eKnBSw1eavBSg5cavNTgpQYvNXipwUsNXmrwUoOXGrzU4KUGLzV4qcFLDV5q8FKDlxq81OClBi81eKnBSw1eavBSg5cavNTgpQYvNXipwUsNXmrwUoOXGrzU4KUGLzV4qcFLDV5q8FKDlxq81OClBi81eKnBSw1eavBSg5cavNTgpQYvNXipwUsNXmrwUoOXGrzU4KUGLzV4qcFLDV5q8FKDlxq81OClBi81eKnBSw1eavBSg5cavNTgpQYvNXipwUsNXmrwUoOXGrzU4KUGLzV4qcFLDV5q8FKDlxq81OClBi81eKnBSw1eavBSg5cavNTgpQYvNXipwUsNXmrwUoOXGrzU4KUGLzV4qcFLDV5q8FKDlxq81OClBi81eKnBSw1eavBSg5cavNTgpQYvNXipwUsNXmrwUoOXGrzU4KUGLzV4qcFLDV5q8FKDlxq81OClBi81eKnBSw1eavBSg5cavNTgpQYvNXipwUsNXmrwUoOXGrzU4KUGLzV4qcFLDV5q8FKDlxq81OClBi81eKnBSw1eavBSg5cavNTgpQYvNXipwUsNXmrwUoOXGrzU4KUGLzV4qcFLDV5q8FKDlxq81OClBi81eKnBSw1eavBSg5cavNTgpQYvNXipwUsNXmrwUoOXGrzU4KUGLzV4qcFLDV5q8FKDlxq81OClBi81eKnBSw1eavBSg5cavNTgpQYvNXipwUsNXmrwUoOXGrzU4KUGLzV4qcFLDV5q8FKDlxq81OClBi81eKnBSw1eavBSg5cavNTgpQYvNXipwUsNXmrwUoOXGrzU4KUGLzV4qcFLDV5q8FKDlxq81OClBi81eKnBSw1eavBSg5cavNTgpQYvNXipwUsNXmrwUoOXGrzU4KUGLzV4qcFLDV5q8FKDlxq81OClBi81eKnBSw1eavBSg5cavNTgpQYvNXipwUsNXmrwUoOXGrzU4KUGLzV4qcFLDV5q8FKDlxq81OClBi81eKnBSw1eavBSg5cavNTgpQYvNXipwUsNXmrwUoOXGrzU4KUGLzV4qcFLDV5q8FKDlxq81OClBi81eKnBSw1eavBSg5cavNTgpQYvNXipwUsNXmrwUoOXGrzU4KUGLzV4qcFLDV5q8FKDlxq81OClBi81eKnBSw1eavBSg5cavNTgpQYvNXipwUsNXmrwUoOXGrzU4KUGLzV4qcFLDV5q8FKDlxq81OClBi81eKnBSw1eavBSg5cavNTgpQYvNXipwUsNXmrwUoOXGrzU4KUGLzV4qcFLDV5q8FKDlxq81OClBi81eKnBSw1eavBSg5cavNTgpQYvNXipwUsNXmrwUoOXGrzU4KUGLzV4qcFLDV5q8FKDlxq81OClBi81eKnBSw1eavBSg5cavNTgpQYvNXipwUsNXmrwUoOXGrzU4KUGLzV4qcFLDV5q8FKDlxq81OClBi81eKnBSw1eavBSg5cavNTgpQYvNXipwUsNXmrwUoOXGrzU4KUGLzV4qcFLDV5q8FKDlxq81OClBi81eKnBSw1eavBSg5cavNTgpQYvNXipwUsNXmrwUoOXGrzU4KUGLzV4qcFLDV5q8FKDlxq81OClBi81eKnBSw1eavBSg5cavNTgpQYvNXipwUsNXmrwUoOXGrzU4KUGLzV4qcFLDV5q8FKDlxq81OClBi81eKnBSw1eavBSg5cavNTgpQYvNXipwUsNXmrwUoOXGrzU4KUGLzV4qcFLDV5q8FKDlxq81OClBi81eKnBSw1eavBSg5cavNTgpQYvNXipwUsNXmrwUoOXGrzU4KUGLzV4qcFLDV5q8FKDlxq81OClBi81eKnBSw1eavBSg5cavNTgpQYvNXipwUsNXmrwUoOXGrzU4KUGLzV4qcFLDV5q8FKDlxq81OClBi81eKnBSw1eavBSg5cavNTgpQYvNXipwUsNXmrwUoOXGrzU4KUGLzV4qcFLDV5q8FKDlxq81OClBi81eKnBSw1eavBSg5cavNTgpQYvNXipwUsNXmrwUoOXGrzU4KUGLzV4qcFLDV5q8FKDlxq81OClBi81eKnBSw1eavBSg5cavNTgpQYvNXipwUsNXmrwUoOXGrzU4KUGLzV4qcFLDV5q8FKDlxq81OClBi81eKnBSw1eavBSg5cavNTgpQYvNXipwUsNXmrwUoOXGrzU4KUGLzV4qcFLDV5q8FKDlxq81OClBi81eKnBSw1eavBSg5cavNTgpQYvNXipwUsNXmrwUoOXGrzU4KUGLzV4qcFLDV5q8FKDlxq81OClBi81eKnBSw1eavBSg5cavNTgpQYvNXipwUsNXmrwUoOXGrzU4KUGLzV4qcFLDV5q8FKDlxq81OClBi81eKnBSw1eavBSg5cavNTgpQYvNXipwUsNXmrwUoOXGrzU4KUGLzV4qcFLDV5q8FKDlxq81OClBi81eKnBSw1eavBSg5cavNTgpQYvNXipwUsNXmrwUoOXGrzU4KUGLzV4qcFLDV5q8FKDlxq81OClBi81eKnBSw1eavBSg5cavNTgpQYvNXipwUsNXmrwUoOXGrzU4KUGLzV4qclLTV5q8lKTl5q81OSlJi81eanJS01eavJSk5eavNTkpSYvNXmpyUtNXmryUpOXmrzU5KUmLzV5qclLTV5q8lKTl5q81OSlJi81eanJS01eavJSk5eavNTkpSYvNXmpyUtNXmryUpOXmrzU5KUmLzV5qclLTV5q8lKTl5q81OSlJi81eanJS01eavJSk5eavNTkpSYvNXmpyUtNXmryUpOXmrzU5KUmLzV5qclLTV5q8lKTl5q81OSlJi81eanJS01eavJSk5eavNTkpSYvNXmpyUtNXmryUpOXmrzU5KUmLzV5qclLTV5q8lKTl5q81OSlJi81eanJS01eavJSk5eavNTkpSYvNXmpyUtNXmryUpOXmrzU5KUmLzV5qclLTV5q8lKTl5q81OSlJi81eanJS01eavJSk5eavNTkpSYvNXmpyUtNXmryUpOXmrzU5KUmLzV5qclLTV5q8lKTl5q81OSlJi81eanJS01eavJSk5eavNTkpSYvNXmpyUtNXmryUpOXmrzU5KUmLzV5qclLTV5q8lKTl5q81OSlJi81eanJS01eavJSk5eavNTkpSYvNXmpyUtNXmryUpOXmrzU5KUmLzV5qclLTV5q8lKTl5q81OSlJi81eanJS01eavJSk5eavNTkpSYvNXmpyUtNXmryUpOXmrzU5KUmLzV5qclLTV5q8lKTl5q81OSlJi81eanJS01eavJSk5eavNTkpSYvNXmpyUtNXmryUpOXmrzU5KUmLzV5qclLTV5q8lKTl5q81OSlJi81eanJS01eavJSk5eavNTkpSYvNXmpyUtNXmryUpOXmrzU5KUmLzV5qclLTV5q8lKTl5q81OSlJi81eanJS01eavJSk5eavNTkpSYvNXmpyUtNXmryUpOXmrzU5KUmLzV5qclLTV5q8lKTl5q81OSlJi81eanJS01eavJSk5eavNTkpSYvNXmpyUtNXmryUpOXmrzU5KUmLzV5qclLTV5q8lKTl5q81OSlJi81eanJS01eavJSk5eavNTkpSYvNXmpyUtNXmryUpOXmrzU5KUmLzV5qclLTV5q8lKTl5q81OSlJi81eanJS01eavJSk5eavNTkpSYvNXmpyUtNXmryUpOXmrzU5KUmLzV5qclLTV5q8lKTl5q81OSlJi81eanJS01eavJSk5eavNTkpSYvNXmpyUtNXmryUpOXmrzU5KUmLzV5qclLTV5q8lKTl5q81OSlJi81eanJS01eavJSk5eavNTkpSYvNXmpyUtNXmryUpOXmrzU5KUmLzV5qclLTV5q8lKTl5q81OSlJi81eanJS01eavJSk5eavNTkpSYvNXmpyUtNXmryUpOXmrzU5KUmLzV5qclLTV5q8lKTl5q81OSlJi81eanJS01eavJSk5eavNTkpSYvNXmpyUtNXmryUpOXmrzU5KUmLzV5qclLTV5q8lKTl5q81OSlJi81eanJS01eavJSk5eavNTkpSYvNXmpyUtNXmryUpOXmrzU5KUmLzV5qclLTV5q8lKTl5q81OSlJi81eanJS01eavJSk5eavNTkpSYvNXmpyUtNXmryUpOXmrzU5KUmLzV5qclLTV5q8lKTl5q81OSlJi81eanJS01eavJSk5eavNTkpSYvNXmpyUtNXmryUpOXmrzU5KUmLzV5qclLTV5q8lKTl5q81OSlJi81eanJS01eavJSk5eavNTkpSYvNXmpyUtNXmryUpOXmrzU5KUmLzV5qclLTV5q8lKTl5q81OSlJi81eanJS01eavJSk5eavNTkpSYvNXmpyUtNXmryUpOXmrzU5KUmLzV5qclLTV5q8lKTl5q81OSlJi81eanJS01eavJSk5eavNTkpSYvNXmpyUtNXmryUpOXmrzU5KUmLzV5qclLTV5q8lKTl5q81OSlJi81eanJS01eavJSk5eavNTkpSYvNXmpyUtNXmryUpOXmrzU5KUmLzV5qclLTV5q8lKTl5q81OSlJi81eanJS01eavJSk5eavNTkpSYvNXmpyUtNXmryUpOXmrzU5KUmLzV5qclLTV5q8lKTl5q81OSlJi81eanJS01eavJSk5eavNTkpSYvNXmpyUtNXmryUpOXmrzU5KUmLzV5qclLTV5q8lKTl5q81OSlJi81eanJS01eavJSk5eavNTkpSYvNXmpyUtNXmryUpOXmrzU5KUmLzV5qclLTV5q8lKTl5q81OSlJi81eanJS01eavJSk5eavNTkpSYvNXmpyUtNXmryUpOXmrzU5KUmLzV5qclLTV5q8lKTl5q81OSlJi81eanJS01eavJSk5eavNTkpSYvNXmpyUtNXmryUpOXmrzU5KUmLzV5qclLTV5q8lKTl5q81OSlJi81eanJS01eavJSk5eavNTkpSYvNXmpyUtNXmryUpOXmrzU5KUmLzV5qclLTV5q8lKTl5q81OSlJi81eanJS01eavJSk5eavNTkpSYvNXmpyUtNXmryUpOXmrzU5KUmLzV5qclLTV5q8lKTl5q81OSlJi81eanJS01eavJSk5eavNTkpSYvNXmpyUtNXmryUpOXmrzU5KUmLzV5qclLTV5q8lKTl5q81OSlJi81eanJS01eavJSk5eavNTkpSYvNXmpyUtNXmryUpOXmrzU5KUmLzV5qclLTV5q8lKTl5q81OSlJi81eanJS01eavJSk5eavNTkpSYvNXmpyUtNXmryUpOXmrzU5KUmLzV5qclLTV5q8lKTl5q81OSlJi81eanJS01eavJSk5eavNTkpSYvNXmpyUtNXmryUpOXmrzU5KUmLzV5qclLTV5q8lKTl5q81OSlJi81eanJS01eavJSk5eavNTkpSYvNXmpyUtNXmryUpOXmrzU5KUmLzV5qclLTV5q8lKTl5q81OSlJi81eanJS01eavJSk5eavNTkpSYvNXmpyUtNXmryUpOXmrzU5KUmLzV5qclLTV5q8lKTl5q81OSlJi81eanJS01eavJSk5eavNTkpSYvNXmpyUtNXmryUpOXmrzU5KUmLzV5qclLTV5q8lKTl5q81OSlJi81eanJS01eavJSk5eavNTkpSYvNXmpyUtNXmryUpOXmrzU5KUmLzV5qclLTV5q8lKTl5q81OSlJi81eanJS01eavJSk5eavNTkpSYvNXmpxUstXmrxUouXWrzU4qUWL7V4qcVLLV5q8VKLl1q81OKlFi+1eKnFSy1eavFSi5davNTipRYvtXipxUstXmrxUouXWrzU4qUWL7V4qcVLLV5q8VKLl1q81OKlFi+1eKnFSy1eavFSi5davNTipRYvtXipxUstXmrxUouXWrzU4qUWL7V4qcVLLV5q8VKLl1q81OKlFi+1eKnFSy1eavFSi5davNTipRYvtXipxUstXmrxUouXWrzU4qUWL7V4qcVLLV5q8VKLl1q81OKlFi+1eKnFSy1eavFSi5davNTipRYvtXipxUstXmrxUouXWrzU4qUWL7V4qcVLLV5q8VKLl1q81OKlFi+1eKnFSy1eavFSi5davNTipRYvtXipxUstXmrxUouXWrzU4qUWL7V4qcVLLV5q8VKLl1q81OKlFi+1eKnFSy1eavFSi5davNTipRYvtXipxUstXmrxUouXWrzU4qUWL7V4qcVLLV5q8VKLl1q81OKlFi+1eKnFSy1eavFSi5davNTipRYvtXipxUstXmrxUouXWrzU4qUWL7V4qcVLLV5q8VKLl1q81OKlFi+1eKnFSy1eavFSi5davNTipRYvtXipxUstXmrxUouXWrzU4qUWL7V4qcVLLV5q8VKLl1q81OKlFi+1eKnFSy1eavFSi5davNTipRYvtXipxUstXmrxUouXWrzU4qUWL7V4qcVLLV5q8VKLl1q81OKlFi+1eKnFSy1eavFSi5davNTipRYvtXipxUstXmrxUouXWrzU4qUWL7V4qcVLLV5q8VKLl1q81OKlFi+1eKnFSy1eavFSi5davNTipRYvtXipxUstXmrxUouXWrzU4qUWL7V4qcVLLV5q8VKLl1q81OKlFi+1eKnFSy1eavFSi5davNTipRYvtXipxUstXmrxUouXWrzU4qUWL7V4qcVLLV5q8VKLl1q81OKlFi+1eKnFSy1eavFSi5davNTipRYvtXipxUstXmrxUouXWrzU4qUWL7V4qcVLLV5q8VKLl1q81OKlFi+1eKnFSy1eavFSi5davNTipRYvtXipxUstXmrxUouXWrzU4qUWL7V4qcVLLV5q8VKLl1q81OKlFi+1eKnFSy1eavFSi5davNTipRYvtXipxUstXmrxUouXWrzU4qUWL7V4qcVLLV5q8VKLl1q81OKlFi+1eKnFSy1eavFSi5davNTipRYvtXipxUstXmrxUouXWrzU4qUWL7V4qcVLLV5q8VKLl1q81OKlFi+1eKnFSy1eavFSi5davNTipRYvtXipxUstXmrxUouXWrzU4qUWL7V4qcVLLV5q8VKLl1q81OKlFi+1eKnFSy1eavFSi5davNTipRYvtXipxUstXmrxUouXWrzU4qUWL7V4qcVLLV5q8VKLl1q81OKlFi+1eKnFSy1eavFSi5davNTipRYvtXipxUstXmrxUouXWrzU4qUWL7V4qcVLLV5q8VKLl1q81OKlFi+1eKnFSy1eavFSi5davNTipRYvtXipxUstXmrxUouXWrzU4qUWL7V4qcVLLV5q8VKLl1q81OKlFi+1eKnFSy1eavFSi5davNTipRYvtXipxUstXmrxUouXWrzU4qUWL7V4qcVLLV5q8VKLl1q81OKlFi+1eKnFSy1eavFSi5davNTipRYvtXipxUstXmrxUouXWrzU4qUWL7V4qcVLLV5q8VKLl1q81OKlFi+1eKnFSy1eavFSi5davNTipRYvtXipxUstXmrxUouXWrzU4qUWL7V4qcVLLV5q8VKLl1q81OKlFi+1eKnFSy1eavFSi5davNTipRYvtXipxUstXmrxUouXWrzU4qUWL7V4qcVLLV5q8VKLl1q81OKlFi+1eKnFSy1eavFSi5davNTipRYvtXipxUstXmrxUouXWrzU4qUWL7V4qcVLLV5q8VKLl1q81OKlFi+1eKnFSy1eavFSi5davNTipRYvtXipxUstXmrxUouXWrzU4qUWL7V4qcVLLV5q8VKLl1q81OKlFi+1eKnFSy1eavFSi5davNTipRYvtXipxUstXmrxUouXWrzU4qUWL7V4qcVLLV5q8VKLl1q81OKlFi+1eKnFSy1eavFSi5davNTipRYvtXipxUstXmrxUouXWrzU4qUWL7V4qcVLLV5q8VKLl1q81OKlFi+1eKnFSy1eavFSi5davNTipRYvtXipxUstXmrxUouXWrzU4qUWL7V4qcVLLV5q8VKLl1q81OKlFi+1eKnFSy1eavFSi5davNTipRYvtXipxUstXmrxUouXWrzU4qUWL7V4qcVLLV5q8VKLl1q81OKlFi+1eKnFSy1eavFSi5davNTipRYvtXipxUstXmrxUouXWrzU4qUWL7V4qcVLLV5q8VKLl1q81OKlFi+1eKnFSy1eavFSi5davNTipRYvtXipxUstXmrxUouXWrzU4qUWL7V4qcVLLV5q8VKLl1q81OKlFi+1eKnFSy1eavFSi5davNTipRYvtXipxUstXmrxUouXWrzU4qUWL7V4qcVLLV5q8VKLl1q81OKlFi+1eKnFSy1eavFSi5davNTipRYvtXipxUstXmrxUouXWrzU4qUWL7V4qcVLLV5q8VKLl1q81OKlFi+1eKnFSy1eavFSi5davNTipRYvtXipxUstXmrxUouXWrzU4qUWL7V4qcVLLV5q8VKLl1q81OKlFi+1eKnFSy1eavFSi5davNTipRYvtXipxUstXmrxUouXWrzU4qUWL7V4qcVLLV5q8VKLl1q81OKlFi+1eKnFSy1eavFSi5davNTipRYvtXipxUstXmrxUouXWrzU4qUWL7V4qcVLLV5q8VKLl1q81OKlFi+1eKnFSy1eavFSi5davNTipRYvtXipxUstXmrxUouXWrzU4qUWL7V4qcVLLV5q8VKLl1q81OKlFi+1eKnFSy1eavFSi5davNTipRYvtXipxUstXmrxUouXWrzU4qUWL7V4qcVLLV5q8VKLl1q81OKlFi+1eKnFSy1eavFSi5davNTipRYvtXipxUstXmrxUouXWrzU4qUWL7V4qcVLLV5q8VKLl1q81OKlFi+1eKnFSy1eavFSi5davNTipRYvtXipxUstXmrxUouXWrzU4qUWL7V4qcVLLV5q8VKLl1q81OKlFi+1eKnNS21eavNSm5favNTmpTYvtXmpzUttXmrzUpuX2rzU5qU2L7V5qc1LbV5q81Kbl9q81OalNi+1eanNS21eavNSm5favNTmpTYvtXmpzUttXmrzUpuX2rzU5qU2L7V5qc1LbV5q81Kbl9q81OalNi+1eanNS21eavNSm5favNTmpTYvtXmpzUttXmrzUpuX2rzU5qU2L7V5qc1LbV5q81Kbl9q81OalNi+1eanNS21eavNSm5favNTmpTYvtXmpzUttXmrzUpuX2rzU5qU2L7V5qc1LbV5q81Kbl9q81OalNi+1eanNS21eavNSm5favNTmpTYvtXmpzUttXmrzUpuX2rzU5qU2L7V5qc1LbV5q81Kbl9q81OalNi+1eanNS21eavNSm5favNTmpTYvtXmpzUttXmrzUpuX2rzU5qU2L7V5qc1LbV5q81Kbl9q81OalNi+1eanNS21eavNSm5favNTmpTYvtXmpzUttXmrzUpuX2rzU5qU2L7V5qc1LbV5q81Kbl9q81OalNi+1eanNS21eavNSm5favNTmpTYvtXmpzUttXmrzUpuX2rzU5qU2L7V5qc1LbV5q81Kbl9q81OalNi+1eanNS21eavNSm5favNTmpTYvtXmpzUttXmrzUpuX2rzU5qU2L7V5qc1LbV5q81Kbl9q81OalNi+1eanNS21eavNSm5favNTmpTYvtXmpzUttXmrzUpuX2rzU5qU2L7V5qc1LbV5q81Kbl9q81OalNi+1eanNS21eavNSm5favNTmpTYvtXmpzUttXmrzUpuX2rzU5qU2L7V5qc1LbV5q81Kbl9q81OalNi+1eanNS21eavNSm5favNTmpTYvtXmpzUttXmrzUpuX2rzU5qU2L7V5qc1LbV5q81Kbl9q81OalNi+1eanNS21eavNSm5favNTmpTYvtXmpzUttXmrzUpuX2rzU5qU2L7V5qc1LbV5q81Kbl9q81OalNi+1eanNS21eavNSm5favNTmpTYvtXmpzUttXmrzUpuX2rzU5qU2L7V5qc1LbV5q81Kbl9q81OalNi+1eanNS21eavNSm5favNTmpTYvtXmpzUttXmrzUpuX2rzU5qU2L7V5qc1LbV5q81Kbl9q81OalNi+1eanNS21eavNSm5favNTmpTYvtXmpzUttXmrzUpuX2rzU5qU2L7V5qc1LbV5q81Kbl9q81OalNi+1eanNS21eavNSm5favNTmpTYvtXmpzUttXmrzUpuX2rzU5qU2L7V5qc1LbV5q81Kbl9q81OalNi+1eanNS21eavNSm5favNTmpTYvtXmpzUttXmrzUpuX2rzU5qU2L7V5qc1LbV5q81Kbl9q81OalNi+1eanNS21eavNSm5favNTmpTYvtXmpzUttXmrzUpuX2rzU5qU2L7V5qc1LbV5q81Kbl9q81OalNi+1eanNS21eavNSm5favNTmpTYvtXmpzUttXmrzUpuX2rzU5qU2L7V5qc1LbV5q81Kbl9q81OalNi+1eanNS21eavNSm5favNTmpTYvtXmpzUttXmrzUpuX2rzU5qU2L7V5qc1LbV5q81Kbl9q81OalNi+1eanNS21eavNSm5favNTmpTYvtXmpzUttXmrzUpuX2rzU5qU2L7V5qc1LbV5q81Kbl9q81OalNi+1eanNS21eavNSm5favNTmpTYvtXmpzUttXmrzUpuX2rzU5qU2L7V5qc1LbV5q81Kbl9q81OalNi+1eanNS21eavNSm5favNTmpTYvtXmpzUttXmrzUpuX2rzU5qU2L7V5qc1LbV5q81Kbl9q81OalNi+1eanNS21eavNSm5favNTmpTYvtXmpzUttXmrzUpuX2rzU5qU2L7V5qc1LbV5q81Kbl9q81OalNi+1eanNS21eavNSm5favNTmpTYvtXmpzUttXmrzUpuX2rzU5qU2L7V5qc1LbV5q81Kbl9q81OalNi+1eanNS21eavNSm5favNTmpTYvtXmpzUttXmrzUpuX2rzU5qU2L7V5qc1LbV5q81Kbl9q81OalNi+1eanNS21eavNSm5favNTmpTYvtXmpzUttXmrzUpuX2rzU5qU2L7V5qc1LbV5q81Kbl9q81OalNi+1eanNS21eavNSm5favNTmpTYvtXmpzUttXmrzUpuX2rzU5qU2L7V5qc1LbV5q81Kbl9q81OalNi+1eanNS21eavNSm5favNTmpTYvtXmpzUttXmrzUpuX2rzU5qU2L7V5qc1LbV5q81Kbl9q81OalNi+1eanNS21eavNSm5favNTmpTYvtXmpzUttXmrzUpuX2rzU5qU2L7V5qc1LbV5q81Kbl9q81OalNi+1eanNS21eavNSm5favNTmpTYvtXmpzUttXmrzUpuX2rzU5qU2L7V5qc1LbV5q81Kbl9q81OalNi+1eanNS21eavNSm5favNTmpTYvtXmpzUttXmrzUpuX2rzU5qU2L7V5qc1LbV5q81Kbl9q81OalNi+1eanNS21eavNSm5favNTmpTYvtXmpzUttXmrzUpuX2rzU5qU2L7V5qc1LbV5q81Kbl9q81OalNi+1eanNS21eavNSm5favNTmpTYvtXmpzUttXmrzUpuX2rzU5qU2L7V5qc1LbV5q81Kbl9q81OalNi+1eanNS21eavNSm5favNTmpTYvtXmpzUttXmrzUpuX2rzU5qU2L7V5qc1LbV5q81Kbl9q81OalNi+1eanNS21eavNSm5favNTmpTYvtXmpzUttXmrzUpuX2rzU5qU2L7V5qc1LbV5q81Kbl9q81OalNi+1eanNS21eavNSm5favNTmpTYvtXmpzUtt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",
    "file_map": {
        "18": {
            "source": "pub mod bn254;\nuse crate::{runtime::is_unconstrained, static_assert};\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    /// Asserts that `self` can be represented in `bit_size` bits.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{bit_size}`.\n    // docs:start:assert_max_bit_size\n    pub fn assert_max_bit_size<let BIT_SIZE: u32>(self) {\n        // docs:end:assert_max_bit_size\n        static_assert(\n            BIT_SIZE < modulus_num_bits() as u32,\n            \"BIT_SIZE must be less than modulus_num_bits\",\n        );\n        __assert_max_bit_size(self, BIT_SIZE);\n    }\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_le_bits\n    pub fn to_le_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_le_bits\n        let bits = __to_le_bits(self);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[N - 1 - i] != p[N - 1 - i]) {\n                        assert(p[N - 1 - i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_be_bits\n    pub fn to_be_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_be_bits\n        let bits = __to_be_bits(self);\n\n        if !is_unconstrained() {\n            // Ensure that the decomposition does not overflow the modulus\n            let p = modulus_be_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[i] != p[i]) {\n                        assert(p[i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its little endian byte decomposition as a `[u8;N]` array\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_le_bytes\n    pub fn to_le_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_le_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_le_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[N - 1 - i] != p[N - 1 - i]) {\n                        assert(bytes[N - 1 - i] < p[N - 1 - i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    /// Decomposes `self` into its big endian byte decomposition as a `[u8;N]` array of length required to represent the field modulus\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_be_bytes\n    pub fn to_be_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_be_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_be_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_be_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[i] != p[i]) {\n                        assert(bytes[i] < p[i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    fn to_le_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, \"radix must be greater than 1\");\n            static_assert(radix <= 256, \"radix must be less than or equal to 256\");\n            static_assert(radix & (radix - 1) == 0, \"radix must be a power of 2\");\n        }\n        __to_le_radix(self, radix)\n    }\n\n    fn to_be_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, \"radix must be greater than 1\");\n            static_assert(radix <= 256, \"radix must be less than or equal to 256\");\n            static_assert(radix & (radix - 1) == 0, \"radix must be a power of 2\");\n        }\n        __to_be_radix(self, radix)\n    }\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b: [u1; 32] = exponent.to_le_bits();\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32 - i] as Field) * (r * self) + (1 - b[32 - i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x `elem` {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n\n    /// Convert a little endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_le_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n\n    /// Convert a big endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_be_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[N - 1 - i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n}\n\n#[builtin(apply_range_constraint)]\nfn __assert_max_bit_size(value: Field, bit_size: u32) {}\n\n// `_radix` must be less than 256\n#[builtin(to_le_radix)]\nfn __to_le_radix<let N: u32>(value: Field, radix: u32) -> [u8; N] {}\n\n// `_radix` must be less than 256\n#[builtin(to_be_radix)]\nfn __to_be_radix<let N: u32>(value: Field, radix: u32) -> [u8; N] {}\n\n/// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n/// This slice will be zero padded should not all bits be necessary to represent `self`.\n///\n/// # Failures\n/// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n/// be able to represent the original `Field`.\n///\n/// # Safety\n/// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n/// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n/// wrap around due to overflow when verifying the decomposition.\n#[builtin(to_le_bits)]\nfn __to_le_bits<let N: u32>(value: Field) -> [u1; N] {}\n\n/// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n/// This array will be zero padded should not all bits be necessary to represent `self`.\n///\n/// # Failures\n/// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n/// be able to represent the original `Field`.\n///\n/// # Safety\n/// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n/// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n/// wrap around due to overflow when verifying the decomposition.\n#[builtin(to_be_bits)]\nfn __to_be_bits<let N: u32>(value: Field) -> [u1; N] {}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n/// An unconstrained only built in to efficiently compare fields.\n#[builtin(field_less_than)]\nunconstrained fn __field_less_than(x: Field, y: Field) -> bool {}\n\npub(crate) unconstrained fn field_less_than(x: Field, y: Field) -> bool {\n    __field_less_than(x, y)\n}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unconstrained context\n        unsafe {\n            field_less_than(x, y)\n        }\n    } else {\n        let x_bytes: [u8; 32] = x.to_le_bytes();\n        let y_bytes: [u8; 32] = y.to_le_bytes();\n        let mut x_is_lt = false;\n        let mut done = false;\n        for i in 0..32 {\n            if (!done) {\n                let x_byte = x_bytes[32 - 1 - i] as u8;\n                let y_byte = y_bytes[32 - 1 - i] as u8;\n                let bytes_match = x_byte == y_byte;\n                if !bytes_match {\n                    x_is_lt = x_byte < y_byte;\n                    done = true;\n                }\n            }\n        }\n        x_is_lt\n    }\n}\n\nmod tests {\n    use crate::{panic::panic, runtime, static_assert};\n    use super::{\n        field_less_than, modulus_be_bits, modulus_be_bytes, modulus_le_bits, modulus_le_bytes,\n    };\n\n    #[test]\n    // docs:start:to_be_bits_example\n    fn test_to_be_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_be_bits();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 1, 0]);\n    }\n    // docs:end:to_be_bits_example\n\n    #[test]\n    // docs:start:to_le_bits_example\n    fn test_to_le_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_le_bits();\n        assert_eq(bits, [0, 1, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bits_example\n\n    #[test]\n    // docs:start:to_be_bytes_example\n    fn test_to_be_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_be_bytes();\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_bytes_example\n\n    #[test]\n    // docs:start:to_le_bytes_example\n    fn test_to_le_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_le_bytes();\n        assert_eq(bytes, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_bytes_example\n\n    #[test]\n    // docs:start:to_be_radix_example\n    fn test_to_be_radix() {\n        // 259, in base 256, big endian, is [1, 3].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_be_radix(256);\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 1, 3]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_radix_example\n\n    #[test]\n    // docs:start:to_le_radix_example\n    fn test_to_le_radix() {\n        // 259, in base 256, little endian, is [3, 1].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_le_radix(256);\n        assert_eq(bytes, [3, 1, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_radix_example\n\n    #[test(should_fail_with = \"radix must be greater than 1\")]\n    fn test_to_le_radix_1() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(1);\n        } else {\n            panic(f\"radix must be greater than 1\");\n        }\n    }\n\n    // Updated test to account for Brillig restriction that radix must be greater than 2\n    #[test(should_fail_with = \"radix must be greater than 1\")]\n    fn test_to_le_radix_brillig_1() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 1;\n            let _: [u8; 8] = field.to_le_radix(1);\n        } else {\n            panic(f\"radix must be greater than 1\");\n        }\n    }\n\n    #[test(should_fail_with = \"radix must be a power of 2\")]\n    fn test_to_le_radix_3() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(3);\n        } else {\n            panic(f\"radix must be a power of 2\");\n        }\n    }\n\n    #[test]\n    fn test_to_le_radix_brillig_3() {\n        // this test should only fail in constrained mode\n        if runtime::is_unconstrained() {\n            let field = 1;\n            let out: [u8; 8] = field.to_le_radix(3);\n            let mut expected = [0; 8];\n            expected[0] = 1;\n            assert(out == expected, \"unexpected result\");\n        }\n    }\n\n    #[test(should_fail_with = \"radix must be less than or equal to 256\")]\n    fn test_to_le_radix_512() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(512);\n        } else {\n            panic(f\"radix must be less than or equal to 256\")\n        }\n    }\n\n    #[test(should_fail_with = \"Field failed to decompose into specified 16 limbs\")]\n    unconstrained fn not_enough_limbs_brillig() {\n        let _: [u8; 16] = 0x100000000000000000000000000000000.to_le_bytes();\n    }\n\n    #[test(should_fail_with = \"Field failed to decompose into specified 16 limbs\")]\n    fn not_enough_limbs() {\n        let _: [u8; 16] = 0x100000000000000000000000000000000.to_le_bytes();\n    }\n\n    #[test]\n    unconstrained fn test_field_less_than() {\n        assert(field_less_than(0, 1));\n        assert(field_less_than(0, 0x100));\n        assert(field_less_than(0x100, 0 - 1));\n        assert(!field_less_than(0 - 1, 0));\n    }\n\n    #[test]\n    unconstrained fn test_large_field_values_unconstrained() {\n        let large_field = 0xffffffffffffffff;\n\n        let bits: [u1; 64] = large_field.to_le_bits();\n        assert_eq(bits[0], 1);\n\n        let bytes: [u8; 8] = large_field.to_le_bytes();\n        assert_eq(Field::from_le_bytes::<8>(bytes), large_field);\n\n        let radix_bytes: [u8; 8] = large_field.to_le_radix(256);\n        assert_eq(Field::from_le_bytes::<8>(radix_bytes), large_field);\n    }\n\n    #[test]\n    fn test_large_field_values() {\n        let large_val = 0xffffffffffffffff;\n\n        let bits: [u1; 64] = large_val.to_le_bits();\n        assert_eq(bits[0], 1);\n\n        let bytes: [u8; 8] = large_val.to_le_bytes();\n        assert_eq(Field::from_le_bytes::<8>(bytes), large_val);\n\n        let radix_bytes: [u8; 8] = large_val.to_le_radix(256);\n        assert_eq(Field::from_le_bytes::<8>(radix_bytes), large_val);\n    }\n\n    #[test]\n    fn test_decomposition_edge_cases() {\n        let zero_bits: [u1; 8] = 0.to_le_bits();\n        assert_eq(zero_bits, [0; 8]);\n\n        let zero_bytes: [u8; 8] = 0.to_le_bytes();\n        assert_eq(zero_bytes, [0; 8]);\n\n        let one_bits: [u1; 8] = 1.to_le_bits();\n        let expected: [u1; 8] = [1, 0, 0, 0, 0, 0, 0, 0];\n        assert_eq(one_bits, expected);\n\n        let pow2_bits: [u1; 8] = 4.to_le_bits();\n        let expected: [u1; 8] = [0, 0, 1, 0, 0, 0, 0, 0];\n        assert_eq(pow2_bits, expected);\n    }\n\n    #[test]\n    fn test_pow_32() {\n        assert_eq(2.pow_32(3), 8);\n        assert_eq(3.pow_32(2), 9);\n        assert_eq(5.pow_32(0), 1);\n        assert_eq(7.pow_32(1), 7);\n\n        assert_eq(2.pow_32(10), 1024);\n\n        assert_eq(0.pow_32(5), 0);\n        assert_eq(0.pow_32(0), 1);\n\n        assert_eq(1.pow_32(100), 1);\n    }\n\n    #[test]\n    fn test_sgn0() {\n        assert_eq(0.sgn0(), 0);\n        assert_eq(2.sgn0(), 0);\n        assert_eq(4.sgn0(), 0);\n        assert_eq(100.sgn0(), 0);\n\n        assert_eq(1.sgn0(), 1);\n        assert_eq(3.sgn0(), 1);\n        assert_eq(5.sgn0(), 1);\n        assert_eq(101.sgn0(), 1);\n    }\n\n    #[test(should_fail_with = \"Field failed to decompose into specified 8 limbs\")]\n    fn test_bit_decomposition_overflow() {\n        // 8 bits can't represent large field values\n        let large_val = 0x1000000000000000;\n        let _: [u1; 8] = large_val.to_le_bits();\n    }\n\n    #[test(should_fail_with = \"Field failed to decompose into specified 4 limbs\")]\n    fn test_byte_decomposition_overflow() {\n        // 4 bytes can't represent large field values\n        let large_val = 0x1000000000000000;\n        let _: [u8; 4] = large_val.to_le_bytes();\n    }\n\n    #[test]\n    fn test_to_from_be_bytes_bn254_edge_cases() {\n        if crate::compat::is_bn254() {\n            // checking that decrementing this byte produces the expected 32 BE bytes for (modulus - 1)\n            let mut p_minus_1_bytes: [u8; 32] = modulus_be_bytes().as_array();\n            assert(p_minus_1_bytes[32 - 1] > 0);\n            p_minus_1_bytes[32 - 1] -= 1;\n\n            let p_minus_1 = Field::from_be_bytes::<32>(p_minus_1_bytes);\n            assert_eq(p_minus_1 + 1, 0);\n\n            // checking that converting (modulus - 1) from and then to 32 BE bytes produces the same bytes\n            let p_minus_1_converted_bytes: [u8; 32] = p_minus_1.to_be_bytes();\n            assert_eq(p_minus_1_converted_bytes, p_minus_1_bytes);\n\n            // checking that incrementing this byte produces 32 BE bytes for (modulus + 1)\n            let mut p_plus_1_bytes: [u8; 32] = modulus_be_bytes().as_array();\n            assert(p_plus_1_bytes[32 - 1] < 255);\n            p_plus_1_bytes[32 - 1] += 1;\n\n            let p_plus_1 = Field::from_be_bytes::<32>(p_plus_1_bytes);\n            assert_eq(p_plus_1, 1);\n\n            // checking that converting p_plus_1 to 32 BE bytes produces the same\n            // byte set to 1 as p_plus_1_bytes and otherwise zeroes\n            let mut p_plus_1_converted_bytes: [u8; 32] = p_plus_1.to_be_bytes();\n            assert_eq(p_plus_1_converted_bytes[32 - 1], 1);\n            p_plus_1_converted_bytes[32 - 1] = 0;\n            assert_eq(p_plus_1_converted_bytes, [0; 32]);\n\n            // checking that Field::from_be_bytes::<32> on the Field modulus produces 0\n            assert_eq(modulus_be_bytes().len(), 32);\n            let p = Field::from_be_bytes::<32>(modulus_be_bytes().as_array());\n            assert_eq(p, 0);\n\n            // checking that converting 0 to 32 BE bytes produces 32 zeroes\n            let p_bytes: [u8; 32] = 0.to_be_bytes();\n            assert_eq(p_bytes, [0; 32]);\n        }\n    }\n\n    #[test]\n    fn test_to_from_le_bytes_bn254_edge_cases() {\n        if crate::compat::is_bn254() {\n            // checking that decrementing this byte produces the expected 32 LE bytes for (modulus - 1)\n            let mut p_minus_1_bytes: [u8; 32] = modulus_le_bytes().as_array();\n            assert(p_minus_1_bytes[0] > 0);\n            p_minus_1_bytes[0] -= 1;\n\n            let p_minus_1 = Field::from_le_bytes::<32>(p_minus_1_bytes);\n            assert_eq(p_minus_1 + 1, 0);\n\n            // checking that converting (modulus - 1) from and then to 32 BE bytes produces the same bytes\n            let p_minus_1_converted_bytes: [u8; 32] = p_minus_1.to_le_bytes();\n            assert_eq(p_minus_1_converted_bytes, p_minus_1_bytes);\n\n            // checking that incrementing this byte produces 32 LE bytes for (modulus + 1)\n            let mut p_plus_1_bytes: [u8; 32] = modulus_le_bytes().as_array();\n            assert(p_plus_1_bytes[0] < 255);\n            p_plus_1_bytes[0] += 1;\n\n            let p_plus_1 = Field::from_le_bytes::<32>(p_plus_1_bytes);\n            assert_eq(p_plus_1, 1);\n\n            // checking that converting p_plus_1 to 32 LE bytes produces the same\n            // byte set to 1 as p_plus_1_bytes and otherwise zeroes\n            let mut p_plus_1_converted_bytes: [u8; 32] = p_plus_1.to_le_bytes();\n            assert_eq(p_plus_1_converted_bytes[0], 1);\n            p_plus_1_converted_bytes[0] = 0;\n            assert_eq(p_plus_1_converted_bytes, [0; 32]);\n\n            // checking that Field::from_le_bytes::<32> on the Field modulus produces 0\n            assert_eq(modulus_le_bytes().len(), 32);\n            let p = Field::from_le_bytes::<32>(modulus_le_bytes().as_array());\n            assert_eq(p, 0);\n\n            // checking that converting 0 to 32 LE bytes produces 32 zeroes\n            let p_bytes: [u8; 32] = 0.to_le_bytes();\n            assert_eq(p_bytes, [0; 32]);\n        }\n    }\n\n    /// Convert a little endian bit array to a field element.\n    /// If the provided bit array overflows the field modulus then the Field will silently wrap around.\n    fn from_le_bits<let N: u32>(bits: [u1; N]) -> Field {\n        static_assert(\n            N <= modulus_le_bits().len(),\n            \"N must be less than or equal to modulus_le_bits().len()\",\n        );\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bits[i] as Field) * v;\n            v = v * 2;\n        }\n        result\n    }\n\n    /// Convert a big endian bit array to a field element.\n    /// If the provided bit array overflows the field modulus then the Field will silently wrap around.\n    fn from_be_bits<let N: u32>(bits: [u1; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bits[N - 1 - i] as Field) * v;\n            v = v * 2;\n        }\n        result\n    }\n\n    #[test]\n    fn test_to_from_be_bits_bn254_edge_cases() {\n        if crate::compat::is_bn254() {\n            // checking that decrementing this bit produces the expected 254 BE bits for (modulus - 1)\n            let mut p_minus_1_bits: [u1; 254] = modulus_be_bits().as_array();\n            assert(p_minus_1_bits[254 - 1] > 0);\n            p_minus_1_bits[254 - 1] -= 1;\n\n            let p_minus_1 = from_be_bits::<254>(p_minus_1_bits);\n            assert_eq(p_minus_1 + 1, 0);\n\n            // checking that converting (modulus - 1) from and then to 254 BE bits produces the same bits\n            let p_minus_1_converted_bits: [u1; 254] = p_minus_1.to_be_bits();\n            assert_eq(p_minus_1_converted_bits, p_minus_1_bits);\n\n            // checking that incrementing this bit produces 254 BE bits for (modulus + 4)\n            let mut p_plus_4_bits: [u1; 254] = modulus_be_bits().as_array();\n            assert(p_plus_4_bits[254 - 3] < 1);\n            p_plus_4_bits[254 - 3] += 1;\n\n            let p_plus_4 = from_be_bits::<254>(p_plus_4_bits);\n            assert_eq(p_plus_4, 4);\n\n            // checking that converting p_plus_4 to 254 BE bits produces the same\n            // bit set to 1 as p_plus_4_bits and otherwise zeroes\n            let mut p_plus_4_converted_bits: [u1; 254] = p_plus_4.to_be_bits();\n            assert_eq(p_plus_4_converted_bits[254 - 3], 1);\n            p_plus_4_converted_bits[254 - 3] = 0;\n            assert_eq(p_plus_4_converted_bits, [0; 254]);\n\n            // checking that Field::from_be_bits::<254> on the Field modulus produces 0\n            assert_eq(modulus_be_bits().len(), 254);\n            let p = from_be_bits::<254>(modulus_be_bits().as_array());\n            assert_eq(p, 0);\n\n            // checking that converting 0 to 254 BE bytes produces 254 zeroes\n            let p_bits: [u1; 254] = 0.to_be_bits();\n            assert_eq(p_bits, [0; 254]);\n        }\n    }\n\n    #[test]\n    fn test_to_from_le_bits_bn254_edge_cases() {\n        if crate::compat::is_bn254() {\n            // checking that decrementing this bit produces the expected 254 LE bits for (modulus - 1)\n            let mut p_minus_1_bits: [u1; 254] = modulus_le_bits().as_array();\n            assert(p_minus_1_bits[0] > 0);\n            p_minus_1_bits[0] -= 1;\n\n            let p_minus_1 = from_le_bits::<254>(p_minus_1_bits);\n            assert_eq(p_minus_1 + 1, 0);\n\n            // checking that converting (modulus - 1) from and then to 254 BE bits produces the same bits\n            let p_minus_1_converted_bits: [u1; 254] = p_minus_1.to_le_bits();\n            assert_eq(p_minus_1_converted_bits, p_minus_1_bits);\n\n            // checking that incrementing this bit produces 254 LE bits for (modulus + 4)\n            let mut p_plus_4_bits: [u1; 254] = modulus_le_bits().as_array();\n            assert(p_plus_4_bits[2] < 1);\n            p_plus_4_bits[2] += 1;\n\n            let p_plus_4 = from_le_bits::<254>(p_plus_4_bits);\n            assert_eq(p_plus_4, 4);\n\n            // checking that converting p_plus_4 to 254 LE bits produces the same\n            // bit set to 1 as p_plus_4_bits and otherwise zeroes\n            let mut p_plus_4_converted_bits: [u1; 254] = p_plus_4.to_le_bits();\n            assert_eq(p_plus_4_converted_bits[2], 1);\n            p_plus_4_converted_bits[2] = 0;\n            assert_eq(p_plus_4_converted_bits, [0; 254]);\n\n            // checking that Field::from_le_bits::<254> on the Field modulus produces 0\n            assert_eq(modulus_le_bits().len(), 254);\n            let p = from_le_bits::<254>(modulus_le_bits().as_array());\n            assert_eq(p, 0);\n\n            // checking that converting 0 to 254 LE bytes produces 254 zeroes\n            let p_bits: [u1; 254] = 0.to_le_bits();\n            assert_eq(p_bits, [0; 254]);\n        }\n    }\n}\n",
            "path": "std/field/mod.nr"
        },
        "19": {
            "source": "// Exposed only for usage in `std::meta`\npub(crate) mod poseidon2;\n\nuse crate::default::Default;\nuse crate::embedded_curve_ops::{\n    EmbeddedCurvePoint, EmbeddedCurveScalar, multi_scalar_mul, multi_scalar_mul_array_return,\n};\nuse crate::meta::derive_via;\n\n#[foreign(sha256_compression)]\n// docs:start:sha256_compression\npub fn sha256_compression(input: [u32; 16], state: [u32; 8]) -> [u32; 8] {}\n// docs:end:sha256_compression\n\n#[foreign(keccakf1600)]\n// docs:start:keccakf1600\npub fn keccakf1600(input: [u64; 25]) -> [u64; 25] {}\n// docs:end:keccakf1600\n\npub mod keccak {\n    #[deprecated(\"This function has been moved to std::hash::keccakf1600\")]\n    pub fn keccakf1600(input: [u64; 25]) -> [u64; 25] {\n        super::keccakf1600(input)\n    }\n}\n\n#[foreign(blake2s)]\n// docs:start:blake2s\npub fn blake2s<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake2s\n{}\n\n// docs:start:blake3\npub fn blake3<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake3\n{\n    if crate::runtime::is_unconstrained() {\n        // Temporary measure while Barretenberg is main proving system.\n        // Please open an issue if you're working on another proving system and running into problems due to this.\n        crate::static_assert(\n            N <= 1024,\n            \"Barretenberg cannot prove blake3 hashes with inputs larger than 1024 bytes\",\n        );\n    }\n    __blake3(input)\n}\n\n#[foreign(blake3)]\nfn __blake3<let N: u32>(input: [u8; N]) -> [u8; 32] {}\n\n// docs:start:pedersen_commitment\npub fn pedersen_commitment<let N: u32>(input: [Field; N]) -> EmbeddedCurvePoint {\n    // docs:end:pedersen_commitment\n    pedersen_commitment_with_separator(input, 0)\n}\n\n#[inline_always]\npub fn pedersen_commitment_with_separator<let N: u32>(\n    input: [Field; N],\n    separator: u32,\n) -> EmbeddedCurvePoint {\n    let mut points = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N];\n    for i in 0..N {\n        // we use the unsafe version because the multi_scalar_mul will constrain the scalars.\n        points[i] = from_field_unsafe(input[i]);\n    }\n    let generators = derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n    multi_scalar_mul(generators, points)\n}\n\n// docs:start:pedersen_hash\npub fn pedersen_hash<let N: u32>(input: [Field; N]) -> Field\n// docs:end:pedersen_hash\n{\n    pedersen_hash_with_separator(input, 0)\n}\n\n#[no_predicates]\npub fn pedersen_hash_with_separator<let N: u32>(input: [Field; N], separator: u32) -> Field {\n    let mut scalars: [EmbeddedCurveScalar; N + 1] = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N + 1];\n    let mut generators: [EmbeddedCurvePoint; N + 1] =\n        [EmbeddedCurvePoint::point_at_infinity(); N + 1];\n    let domain_generators: [EmbeddedCurvePoint; N] =\n        derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n\n    for i in 0..N {\n        scalars[i] = from_field_unsafe(input[i]);\n        generators[i] = domain_generators[i];\n    }\n    scalars[N] = EmbeddedCurveScalar { lo: N as Field, hi: 0 as Field };\n\n    let length_generator: [EmbeddedCurvePoint; 1] =\n        derive_generators(\"pedersen_hash_length\".as_bytes(), 0);\n    generators[N] = length_generator[0];\n    multi_scalar_mul_array_return(generators, scalars, true)[0].x\n}\n\n#[field(bn254)]\n#[inline_always]\npub fn derive_generators<let N: u32, let M: u32>(\n    domain_separator_bytes: [u8; M],\n    starting_index: u32,\n) -> [EmbeddedCurvePoint; N] {\n    crate::assert_constant(domain_separator_bytes);\n    // TODO(https://github.com/noir-lang/noir/issues/5672): Add back assert_constant on starting_index\n    __derive_generators(domain_separator_bytes, starting_index)\n}\n\n#[builtin(derive_pedersen_generators)]\n#[field(bn254)]\nfn __derive_generators<let N: u32, let M: u32>(\n    domain_separator_bytes: [u8; M],\n    starting_index: u32,\n) -> [EmbeddedCurvePoint; N] {}\n\n#[field(bn254)]\n// Same as from_field but:\n// does not assert the limbs are 128 bits\n// does not assert the decomposition does not overflow the EmbeddedCurveScalar\nfn from_field_unsafe(scalar: Field) -> EmbeddedCurveScalar {\n    // Safety: xlo and xhi decomposition is checked below\n    let (xlo, xhi) = unsafe { crate::field::bn254::decompose_hint(scalar) };\n    // Check that the decomposition is correct\n    assert_eq(scalar, xlo + crate::field::bn254::TWO_POW_128 * xhi);\n    EmbeddedCurveScalar { lo: xlo, hi: xhi }\n}\n\npub fn poseidon2_permutation<let N: u32>(input: [Field; N], state_len: u32) -> [Field; N] {\n    assert_eq(input.len(), state_len);\n    poseidon2_permutation_internal(input)\n}\n\n#[foreign(poseidon2_permutation)]\nfn poseidon2_permutation_internal<let N: u32>(input: [Field; N]) -> [Field; N] {}\n\n// Generic hashing support.\n// Partially ported and impacted by rust.\n\n// Hash trait shall be implemented per type.\n#[derive_via(derive_hash)]\npub trait Hash {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher;\n}\n\n// docs:start:derive_hash\ncomptime fn derive_hash(s: TypeDefinition) -> Quoted {\n    let name = quote { $crate::hash::Hash };\n    let signature = quote { fn hash<H>(_self: Self, _state: &mut H) where H: $crate::hash::Hasher };\n    let for_each_field = |name| quote { _self.$name.hash(_state); };\n    crate::meta::make_trait_impl(\n        s,\n        name,\n        signature,\n        for_each_field,\n        quote {},\n        |fields| fields,\n    )\n}\n// docs:end:derive_hash\n\n// Hasher trait shall be implemented by algorithms to provide hash-agnostic means.\n// TODO: consider making the types generic here ([u8], [Field], etc.)\npub trait Hasher {\n    fn finish(self) -> Field;\n\n    fn write(&mut self, input: Field);\n}\n\n// BuildHasher is a factory trait, responsible for production of specific Hasher.\npub trait BuildHasher {\n    type H: Hasher;\n\n    fn build_hasher(self) -> H;\n}\n\npub struct BuildHasherDefault<H>;\n\nimpl<H> BuildHasher for BuildHasherDefault<H>\nwhere\n    H: Hasher + Default,\n{\n    type H = H;\n\n    fn build_hasher(_self: Self) -> H {\n        H::default()\n    }\n}\n\nimpl<H> Default for BuildHasherDefault<H>\nwhere\n    H: Hasher + Default,\n{\n    fn default() -> Self {\n        BuildHasherDefault {}\n    }\n}\n\nimpl Hash for Field {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self);\n    }\n}\n\nimpl Hash for u1 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u8 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u16 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u32 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u64 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u128 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i8 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as u8 as Field);\n    }\n}\n\nimpl Hash for i16 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as u16 as Field);\n    }\n}\n\nimpl Hash for i32 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as u32 as Field);\n    }\n}\n\nimpl Hash for i64 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as u64 as Field);\n    }\n}\n\nimpl Hash for bool {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for () {\n    fn hash<H>(_self: Self, _state: &mut H)\n    where\n        H: Hasher,\n    {}\n}\n\nimpl<T, let N: u32> Hash for [T; N]\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<T> Hash for [T]\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.len().hash(state);\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<A, B> Hash for (A, B)\nwhere\n    A: Hash,\n    B: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n    }\n}\n\nimpl<A, B, C> Hash for (A, B, C)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n    }\n}\n\nimpl<A, B, C, D> Hash for (A, B, C, D)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n    D: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n    }\n}\n\nimpl<A, B, C, D, E> Hash for (A, B, C, D, E)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n    D: Hash,\n    E: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n        self.4.hash(state);\n    }\n}\n\n// Some test vectors for Pedersen hash and Pedersen Commitment.\n// They have been generated using the same functions so the tests are for now useless\n// but they will be useful when we switch to Noir implementation.\n#[test]\nfn assert_pedersen() {\n    assert_eq(\n        pedersen_hash_with_separator([1], 1),\n        0x1b3f4b1a83092a13d8d1a59f7acb62aba15e7002f4440f2275edb99ebbc2305f,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1], 1),\n        EmbeddedCurvePoint {\n            x: 0x054aa86a73cb8a34525e5bbed6e43ba1198e860f5f3950268f71df4591bde402,\n            y: 0x209dcfbf2cfb57f9f6046f44d71ac6faf87254afc7407c04eb621a6287cac126,\n            is_infinite: false,\n        },\n    );\n\n    assert_eq(\n        pedersen_hash_with_separator([1, 2], 2),\n        0x26691c129448e9ace0c66d11f0a16d9014a9e8498ee78f4d69f0083168188255,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2], 2),\n        EmbeddedCurvePoint {\n            x: 0x2e2b3b191e49541fe468ec6877721d445dcaffe41728df0a0eafeb15e87b0753,\n            y: 0x2ff4482400ad3a6228be17a2af33e2bcdf41be04795f9782bd96efe7e24f8778,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3], 3),\n        0x0bc694b7a1f8d10d2d8987d07433f26bd616a2d351bc79a3c540d85b6206dbe4,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3], 3),\n        EmbeddedCurvePoint {\n            x: 0x1fee4e8cf8d2f527caa2684236b07c4b1bad7342c01b0f75e9a877a71827dc85,\n            y: 0x2f9fedb9a090697ab69bf04c8bc15f7385b3e4b68c849c1536e5ae15ff138fd1,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4], 4),\n        0xdae10fb32a8408521803905981a2b300d6a35e40e798743e9322b223a5eddc,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4], 4),\n        EmbeddedCurvePoint {\n            x: 0x07ae3e202811e1fca39c2d81eabe6f79183978e6f12be0d3b8eda095b79bdbc9,\n            y: 0x0afc6f892593db6fbba60f2da558517e279e0ae04f95758587760ba193145014,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5], 5),\n        0xfc375b062c4f4f0150f7100dfb8d9b72a6d28582dd9512390b0497cdad9c22,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5], 5),\n        EmbeddedCurvePoint {\n            x: 0x1754b12bd475a6984a1094b5109eeca9838f4f81ac89c5f0a41dbce53189bb29,\n            y: 0x2da030e3cfcdc7ddad80eaf2599df6692cae0717d4e9f7bfbee8d073d5d278f7,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6], 6),\n        0x1696ed13dc2730062a98ac9d8f9de0661bb98829c7582f699d0273b18c86a572,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6], 6),\n        EmbeddedCurvePoint {\n            x: 0x190f6c0e97ad83e1e28da22a98aae156da083c5a4100e929b77e750d3106a697,\n            y: 0x1f4b60f34ef91221a0b49756fa0705da93311a61af73d37a0c458877706616fb,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7], 7),\n        0x128c0ff144fc66b6cb60eeac8a38e23da52992fc427b92397a7dffd71c45ede3,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7], 7),\n        EmbeddedCurvePoint {\n            x: 0x015441e9d29491b06563fac16fc76abf7a9534c715421d0de85d20dbe2965939,\n            y: 0x1d2575b0276f4e9087e6e07c2cb75aa1baafad127af4be5918ef8a2ef2fea8fc,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8),\n        0x2f960e117482044dfc99d12fece2ef6862fba9242be4846c7c9a3e854325a55c,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8),\n        EmbeddedCurvePoint {\n            x: 0x1657737676968887fceb6dd516382ea13b3a2c557f509811cd86d5d1199bc443,\n            y: 0x1f39f0cb569040105fa1e2f156521e8b8e08261e635a2b210bdc94e8d6d65f77,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9),\n        0x0c96db0790602dcb166cc4699e2d306c479a76926b81c2cb2aaa92d249ec7be7,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9),\n        EmbeddedCurvePoint {\n            x: 0x0a3ceae42d14914a432aa60ec7fded4af7dad7dd4acdbf2908452675ec67e06d,\n            y: 0xfc19761eaaf621ad4aec9a8b2e84a4eceffdba78f60f8b9391b0bd9345a2f2,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10),\n        0x2cd37505871bc460a62ea1e63c7fe51149df5d0801302cf1cbc48beb8dff7e94,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10),\n        EmbeddedCurvePoint {\n            x: 0x2fb3f8b3d41ddde007c8c3c62550f9a9380ee546fcc639ffbb3fd30c8d8de30c,\n            y: 0x300783be23c446b11a4c0fabf6c91af148937cea15fcf5fb054abf7f752ee245,\n            is_infinite: false,\n        },\n    );\n}\n",
            "path": "std/hash/mod.nr"
        },
        "50": {
            "source": "use ecdh::{bjj::BJJ, ECDHTrait, Point};\nuse poseidon::poseidon2::Poseidon2;\n\nmod merkle_tree;\n// The main function is now a true proving circuit.\n// It takes the expected_commitment as a public input and has no return value.\nfn main(\n    alice_priv_key: Field,\n    bob_pub_key_x: Field,\n    bob_pub_key_y: Field,\n    order_id: Field,\n    \n    merkle_proof: [Field; 20],\n    is_even: [bool; 20],\n\n    hash_lock_nonce: pub Field,\n    nullifier_hash: pub Field,\n    root: pub Field,\n) {\n    // --- The internal logic remains identical ---\n    let bob_pub_key = Point::new(bob_pub_key_x, bob_pub_key_y);\n\n    let alice_ecdh: BJJ = BJJ::new(alice_priv_key);\n\n    let shared_secret = alice_ecdh.derive_shared_key(bob_pub_key);\n\n    let reconstructed_hash_lock = Poseidon2::hash([bob_pub_key_x, hash_lock_nonce], 2);\n\n    let derived_commitment = Poseidon2::hash([reconstructed_hash_lock, shared_secret], 2);\n\n    let computed_nullifier_hash = Poseidon2::hash([shared_secret, bob_pub_key_x, order_id], 3);\n\n    let computed_merkle_root = merkle_tree::compute_merkle_root(derived_commitment, merkle_proof, is_even);\n\n    assert(computed_nullifier_hash == nullifier_hash);\n\n    assert(computed_merkle_root == root);\n}\n\n// #[test]\n// fn test_main_circuit_alice() {\n//     // --- 1. SETUP: Identical to before ---\n//     let alice_sk: Field = 0x12345;\n//     let bob_sk: Field = 0x67890;\n//     let hash_lock_nonce: Field = 0xabcde;\n\n//     let bob_ecdh = BJJ::new(bob_sk);\n//     let bob_pk: Point = bob_ecdh.derive_public_key();\n\n//     // --- 2. PRE-COMPUTATION: Calculate the expected result off-circuit ---\n//     let alice_ecdh = BJJ::new(alice_sk);\n//     let expected_shared_secret = alice_ecdh.derive_shared_key(bob_pk);\n\n//     let expected_hash_lock = Poseidon2::hash([bob_pk.x, hash_lock_nonce], 2);\n\n//     let expected_commitment = Poseidon2::hash([expected_hash_lock, expected_shared_secret], 2);\n\n//     // --- 3. EXECUTION & VERIFICATION: Call the circuit with all public inputs ---\n//     // We now pass the `expected_commitment` as the final argument.\n//     // The test will automatically fail if the `assert` inside `main` is not satisfied.\n//     main(alice_sk, bob_pk.x, bob_pk.y, hash_lock_nonce, expected_commitment);\n// }\n",
            "path": "/mnt/c/users/yashs/desktop/zkETHer V2/noir_ecdh_final/circuit_alice/src/main.nr"
        },
        "51": {
            "source": "use poseidon::poseidon2::Poseidon2;\n\npub fn compute_merkle_root(\n    leaf: Field,\n    merkle_proof: [Field; 20],\n    is_even: [bool; 20],\n) -> Field {\n    // temporary variable to store the hash for the current level we are working on\n    let mut hash: Field = leaf;\n    // increment through the levels\n    for i in 0..20 {\n        let (left, right) = if is_even[i] {\n            (hash, merkle_proof[i])\n        } else {\n            (merkle_proof[i], hash)\n        };\n        // compute the hash for the current level\n        hash = Poseidon2::hash([left, right], 2);\n    }\n    // return the root of the Merkle tree\n    hash\n}",
            "path": "/mnt/c/users/yashs/desktop/zkETHer V2/noir_ecdh_final/circuit_alice/src/merkle_tree.nr"
        },
        "52": {
            "source": "use crate::ECDHTrait;\nuse ec::consts::te::{baby_jubjub, BabyJubjub};\nuse ec::tecurve::affine::Point;\n\npub struct BJJ {\n    pub private_key: Field,\n    pub bjj: BabyJubjub,\n}\n\nimpl ECDHTrait for BJJ {\n    fn new(private_key: Field) -> Self {\n        let bjj = baby_jubjub();\n        Self { bjj, private_key }\n    }\n\n    fn derive_public_key(self) -> Point {\n        self.bjj.curve.mul(self.private_key, self.bjj.base8)\n    }\n\n    fn derive_shared_key(self, public_key: Point) -> Field {\n        let shared_key = self.bjj.curve.mul(self.private_key, public_key);\n        shared_key.x\n    }\n}\n",
            "path": "/home/yash/nargo/github.com/yashsharma22003/Noir-Circuits-Tests/v1/packages/ecdh/src/bjj.nr"
        },
        "59": {
            "source": "pub mod affine {\n    // Affine coordinate representation of Twisted Edwards curves\n    // Points are represented by two-dimensional Cartesian coordinates.\n    // Group operations are implemented in terms of those in CurveGroup (in this case, extended Twisted Edwards) coordinates\n    // for reasons of efficiency.\n    // See <https://eprint.iacr.org/2008/522.pdf> for details.\n    use crate::{\n        montcurve::affine::{Curve as MCurve, Point as MPoint},\n        swcurve::affine::{Curve as SWCurve, Point as SWPoint}, tecurve::curvegroup,\n    };\n    use std::cmp::Eq;\n\n    // Curve specification\n    pub struct Curve { // Twisted Edwards curve\n        // Coefficients in defining equation ax^2 + y^2 = 1 + dx^2y^2\n        pub a: Field,\n        pub d: Field,\n        // Generator as point in Cartesian coordinates\n        pub gen: Point,\n    }\n    // Point in Cartesian coordinates\n    pub struct Point {\n        pub x: Field,\n        pub y: Field,\n    }\n\n    impl Point {\n        // Point constructor\n        // #[deprecated(\"It's recommmended to use the external noir-edwards library (https://github.com/noir-lang/noir-edwards)\")]\n        pub fn new(x: Field, y: Field) -> Self {\n            Self { x, y }\n        }\n\n        // Check if zero\n        pub fn is_zero(self) -> bool {\n            self.eq(Point::zero())\n        }\n\n        // Conversion to CurveGroup coordinates\n        pub fn into_group(self) -> curvegroup::Point {\n            let Self { x, y } = self;\n\n            curvegroup::Point::new(x, y, x * y, 1)\n        }\n\n        // Additive identity\n        pub fn zero() -> Self {\n            Point::new(0, 1)\n        }\n\n        // Negation\n        pub fn negate(self) -> Self {\n            let Self { x, y } = self;\n            Point::new(0 - x, y)\n        }\n\n        // Map into prime-order subgroup of equivalent Montgomery curve\n        pub fn into_montcurve(self) -> MPoint {\n            if self.is_zero() {\n                MPoint::zero()\n            } else {\n                let Self { x, y } = self;\n                let x0 = (1 + y) / (1 - y);\n                let y0 = (1 + y) / (x * (1 - y));\n\n                MPoint::new(x0, y0)\n            }\n        }\n    }\n\n    impl Eq for Point {\n        fn eq(self, p: Self) -> bool {\n            let Self { x: x1, y: y1 } = self;\n            let Self { x: x2, y: y2 } = p;\n\n            (x1 == x2) & (y1 == y2)\n        }\n    }\n\n    impl Curve {\n        // Curve constructor\n        pub fn new(a: Field, d: Field, gen: Point) -> Curve {\n            // Check curve coefficients\n            assert(a * d * (a - d) != 0);\n\n            let curve = Curve { a, d, gen };\n\n            // gen should be on the curve\n            assert(curve.contains(curve.gen));\n\n            curve\n        }\n\n        // Conversion to CurveGroup coordinates\n        pub fn into_group(self) -> curvegroup::Curve {\n            let Curve { a, d, gen } = self;\n\n            curvegroup::Curve { a, d, gen: gen.into_group() }\n        }\n\n        // Membership check\n        pub fn contains(self, p: Point) -> bool {\n            let Point { x, y } = p;\n            self.a * x * x + y * y == 1 + self.d * x * x * y * y\n        }\n\n        // Point addition, implemented in terms of mixed addition for reasons of efficiency\n        pub fn add(self, p1: Point, p2: Point) -> Point {\n            self.mixed_add(p1, p2.into_group()).into_affine()\n        }\n\n        // Mixed point addition, i.e. first argument in affine, second in CurveGroup coordinates.\n        pub fn mixed_add(self, p1: Point, p2: curvegroup::Point) -> curvegroup::Point {\n            let Point { x: x1, y: y1 } = p1;\n            let curvegroup::Point { x: x2, y: y2, t: t2, z: z2 } = p2;\n\n            let a = x1 * x2;\n            let b = y1 * y2;\n            let c = self.d * x1 * y1 * t2;\n            let e = (x1 + y1) * (x2 + y2) - a - b;\n            let f = z2 - c;\n            let g = z2 + c;\n            let h = b - self.a * a;\n\n            let x = e * f;\n            let y = g * h;\n            let t = e * h;\n            let z = f * g;\n\n            curvegroup::Point::new(x, y, t, z)\n        }\n\n        // Scalar multiplication with scalar represented by a bit array (little-endian convention).\n        // If k is the natural number represented by `bits`, then this computes p + ... + p k times.\n        pub fn bit_mul<let N: u32>(self, bits: [u1; N], p: Point) -> Point {\n            self.into_group().bit_mul(bits, p.into_group()).into_affine()\n        }\n\n        // Scalar multiplication (p + ... + p n times)\n        pub fn mul(self, n: Field, p: Point) -> Point {\n            self.into_group().mul(n, p.into_group()).into_affine()\n        }\n\n        // Multi-scalar multiplication (n[0]*p[0] + ... + n[N]*p[N], where * denotes scalar multiplication)\n        pub fn msm<let N: u32>(self, n: [Field; N], p: [Point; N]) -> Point {\n            let mut out = Point::zero();\n\n            for i in 0..N {\n                out = self.add(out, self.mul(n[i], p[i]));\n            }\n\n            out\n        }\n\n        // Point subtraction\n        pub fn subtract(self, p1: Point, p2: Point) -> Point {\n            self.add(p1, p2.negate())\n        }\n\n        // Conversion to equivalent Montgomery curve\n        pub fn into_montcurve(self) -> MCurve {\n            let j = 2 * (self.a + self.d) / (self.a - self.d);\n            let k = 4 / (self.a - self.d);\n            let gen_montcurve = self.gen.into_montcurve();\n\n            MCurve::new(j, k, gen_montcurve)\n        }\n\n        // Conversion to equivalent Short Weierstrass curve\n        pub fn into_swcurve(self) -> SWCurve {\n            self.into_montcurve().into_swcurve()\n        }\n\n        // Point mapping into equivalent Short Weierstrass curve\n        pub fn map_into_swcurve(self, p: Point) -> SWPoint {\n            self.into_montcurve().map_into_swcurve(p.into_montcurve())\n        }\n\n        // Point mapping from equivalent Short Weierstrass curve\n        pub fn map_from_swcurve(self, p: SWPoint) -> Point {\n            self.into_montcurve().map_from_swcurve(p).into_tecurve()\n        }\n\n        // Elligator 2 map-to-curve method (via rational map)\n        pub fn elligator2_map(self, u: Field) -> Point {\n            self.into_montcurve().elligator2_map(u).into_tecurve()\n        }\n\n        // Simplified SWU map-to-curve method (via rational map)\n        pub fn swu_map(self, z: Field, u: Field) -> Point {\n            self.into_montcurve().swu_map(z, u).into_tecurve()\n        }\n    }\n}\npub mod curvegroup {\n    // CurveGroup coordinate representation of Twisted Edwards curves\n    // Points are represented by four-dimensional projective coordinates, viz. extended Twisted Edwards coordinates.\n    // See section 3 of <https://eprint.iacr.org/2008/522.pdf> for details.\n    use crate::{\n        montcurve::curvegroup::{Curve as MCurve, Point as MPoint},\n        swcurve::curvegroup::{Curve as SWCurve, Point as SWPoint}, tecurve::affine,\n    };\n    use std::cmp::Eq;\n\n    // Curve specification\n    pub struct Curve { // Twisted Edwards curve\n        // Coefficients in defining equation a(x^2 + y^2)z^2 = z^4 + dx^2y^2\n        pub a: Field,\n        pub d: Field,\n        // Generator as point in projective coordinates\n        pub gen: Point,\n    }\n    // Point in extended twisted Edwards coordinates\n    pub struct Point {\n        pub x: Field,\n        pub y: Field,\n        pub t: Field,\n        pub z: Field,\n    }\n\n    impl Point {\n        // Point constructor\n        pub fn new(x: Field, y: Field, t: Field, z: Field) -> Self {\n            Self { x, y, t, z }\n        }\n\n        // Check if zero\n        pub fn is_zero(self) -> bool {\n            let Self { x, y, t, z } = self;\n            (x == 0) & (y == z) & (y != 0) & (t == 0)\n        }\n\n        // Conversion to affine coordinates\n        pub fn into_affine(self) -> affine::Point {\n            let Self { x, y, t: _t, z } = self;\n\n            affine::Point::new(x / z, y / z)\n        }\n\n        // Additive identity\n        pub fn zero() -> Self {\n            Point::new(0, 1, 0, 1)\n        }\n\n        // Negation\n        pub fn negate(self) -> Self {\n            let Self { x, y, t, z } = self;\n\n            Point::new(0 - x, y, 0 - t, z)\n        }\n\n        // Map into prime-order subgroup of equivalent Montgomery curve\n        pub fn into_montcurve(self) -> MPoint {\n            self.into_affine().into_montcurve().into_group()\n        }\n    }\n\n    impl Eq for Point {\n        fn eq(self, p: Self) -> bool {\n            let Self { x: x1, y: y1, t: _t1, z: z1 } = self;\n            let Self { x: x2, y: y2, t: _t2, z: z2 } = p;\n\n            (x1 * z2 == x2 * z1) & (y1 * z2 == y2 * z1)\n        }\n    }\n\n    impl Curve {\n        // Curve constructor\n        pub fn new(a: Field, d: Field, gen: Point) -> Curve {\n            // Check curve coefficients\n            assert(a * d * (a - d) != 0);\n\n            let curve = Curve { a, d, gen };\n\n            // gen should be on the curve\n            assert(curve.contains(curve.gen));\n\n            curve\n        }\n\n        // Conversion to affine coordinates\n        pub fn into_affine(self) -> affine::Curve {\n            let Curve { a, d, gen } = self;\n\n            affine::Curve { a, d, gen: gen.into_affine() }\n        }\n\n        // Membership check\n        pub fn contains(self, p: Point) -> bool {\n            let Point { x, y, t, z } = p;\n\n            (z != 0)\n                & (z * t == x * y)\n                & (z * z * (self.a * x * x + y * y) == z * z * z * z + self.d * x * x * y * y)\n        }\n\n        // Point addition\n        pub fn add(self, p1: Point, p2: Point) -> Point {\n            let Point { x: x1, y: y1, t: t1, z: z1 } = p1;\n            let Point { x: x2, y: y2, t: t2, z: z2 } = p2;\n\n            let a = x1 * x2;\n            let b = y1 * y2;\n            let c = self.d * t1 * t2;\n            let d = z1 * z2;\n            let e = (x1 + y1) * (x2 + y2) - a - b;\n            let f = d - c;\n            let g = d + c;\n            let h = b - self.a * a;\n\n            let x = e * f;\n            let y = g * h;\n            let t = e * h;\n            let z = f * g;\n\n            Point::new(x, y, t, z)\n        }\n\n        // Point doubling, cf. section 3.3\n        pub fn double(self, p: Point) -> Point {\n            let Point { x, y, t: _t, z } = p;\n\n            let a = x * x;\n            let b = y * y;\n            let c = 2 * z * z;\n            let d = self.a * a;\n            let e = (x + y) * (x + y) - a - b;\n            let g = d + b;\n            let f = g - c;\n            let h = d - b;\n\n            let x0 = e * f;\n            let y0 = g * h;\n            let t0 = e * h;\n            let z0 = f * g;\n\n            Point::new(x0, y0, t0, z0)\n        }\n\n        // Scalar multiplication with scalar represented by a bit array (little-endian convention).\n        // If k is the natural number represented by `bits`, then this computes p + ... + p k times.\n        pub fn bit_mul<let N: u32>(self, bits: [u1; N], p: Point) -> Point {\n            let mut out = Point::zero();\n\n            for i in 0..N {\n                out = self.add(\n                    self.add(out, out),\n                    if (bits[N - i - 1] == 0) {\n                        Point::zero()\n                    } else {\n                        p\n                    },\n                );\n            }\n\n            out\n        }\n\n        // Scalar multiplication (p + ... + p n times)\n        pub fn mul(self, n: Field, p: Point) -> Point {\n            // TODO: temporary workaround until issue 1354 is solved\n            let mut n_as_bits: [u1; 254] = [0; 254];\n            let tmp: [u1; 254] = n.to_le_bits();\n            for i in 0..254 {\n                n_as_bits[i] = tmp[i];\n            }\n\n            self.bit_mul(n_as_bits, p)\n        }\n\n        // Multi-scalar multiplication (n[0]*p[0] + ... + n[N]*p[N], where * denotes scalar multiplication)\n        pub fn msm<let N: u32>(self, n: [Field; N], p: [Point; N]) -> Point {\n            let mut out = Point::zero();\n\n            for i in 0..N {\n                out = self.add(out, self.mul(n[i], p[i]));\n            }\n\n            out\n        }\n\n        // Point subtraction\n        pub fn subtract(self, p1: Point, p2: Point) -> Point {\n            self.add(p1, p2.negate())\n        }\n\n        // Conversion to equivalent Montgomery curve\n        pub fn into_montcurve(self) -> MCurve {\n            self.into_affine().into_montcurve().into_group()\n        }\n\n        // Conversion to equivalent Short Weierstrass curve\n        pub fn into_swcurve(self) -> SWCurve {\n            self.into_montcurve().into_swcurve()\n        }\n\n        // Point mapping into equivalent short Weierstrass curve\n        pub fn map_into_swcurve(self, p: Point) -> SWPoint {\n            self.into_montcurve().map_into_swcurve(p.into_montcurve())\n        }\n\n        // Point mapping from equivalent short Weierstrass curve\n        pub fn map_from_swcurve(self, p: SWPoint) -> Point {\n            self.into_montcurve().map_from_swcurve(p).into_tecurve()\n        }\n\n        // Elligator 2 map-to-curve method (via rational maps)\n        pub fn elligator2_map(self, u: Field) -> Point {\n            self.into_montcurve().elligator2_map(u).into_tecurve()\n        }\n\n        // Simplified SWU map-to-curve method (via rational map)\n        pub fn swu_map(self, z: Field, u: Field) -> Point {\n            self.into_montcurve().swu_map(z, u).into_tecurve()\n        }\n    }\n}\n",
            "path": "/home/yash/nargo/github.com/noir-lang/ec/v0.1.2/src/tecurve.nr"
        },
        "66": {
            "source": "use std::default::Default;\nuse std::hash::Hasher;\n\ncomptime global RATE: u32 = 3;\n\npub struct Poseidon2 {\n    cache: [Field; 3],\n    state: [Field; 4],\n    cache_size: u32,\n    squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2 {\n    #[no_predicates]\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        Poseidon2::hash_internal(input, message_size, message_size != N)\n    }\n\n    pub(crate) fn new(iv: Field) -> Poseidon2 {\n        let mut result =\n            Poseidon2 { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = crate::poseidon2_permutation(self.state, 4);\n    }\n\n    fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(\n        input: [Field; N],\n        in_len: u32,\n        is_variable_length: bool,\n    ) -> Field {\n        let two_pow_64 = 18446744073709551616;\n        let iv: Field = (in_len as Field) * two_pow_64;\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n\npub struct Poseidon2Hasher {\n    _state: [Field],\n}\n\nimpl Hasher for Poseidon2Hasher {\n    fn finish(self) -> Field {\n        let iv: Field = (self._state.len() as Field) * 18446744073709551616; // iv = (self._state.len() << 64)\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..self._state.len() {\n            sponge.absorb(self._state[i]);\n        }\n        sponge.squeeze()\n    }\n\n    fn write(&mut self, input: Field) {\n        self._state = self._state.push_back(input);\n    }\n}\n\nimpl Default for Poseidon2Hasher {\n    fn default() -> Self {\n        Poseidon2Hasher { _state: &[] }\n    }\n}\n",
            "path": "/home/yash/nargo/github.com/noir-lang/poseidon/v0.1.1/src/poseidon2.nr"
        }
    },
    "expression_width": {
        "Bounded": {
            "width": 4
        }
    }
}