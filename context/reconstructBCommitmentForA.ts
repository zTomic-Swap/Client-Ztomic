import { Barretenberg, Fr } from "@aztec/bb.js";
import { Base8, mulPointEscalar } from "@zk-kit/baby-jubjub";

/**
 * Derives Commitment B from Alice's perspective.
 * This function calculates the same commitment as generateCommitmentB,
 * but uses Alice's secret key and Bob's public key.
 *
 * @param publicKeyBob - Bob's (the counterparty's) public key as [x, y] coordinate strings.
 * @param secretKeyAlice - Alice's (the party's) secret key as a hex or decimal string.
 * @param hashlock - The hashlock string originally generated by Alice (from createCommitmentA).
 * @returns A promise that resolves to an object containing Commitment B's string.
 */
export async function deriveCommitmentB(
  publicKeyBob: [string, string], // Bob's Public Key
  secretKeyAlice: string, // Alice's Secret Key
  hashlock: string // Hashlock from createCommitmentA
): Promise<{ commitment: string }> {
  
  // Guard clause to check for valid hashlock string.
  if (!hashlock || typeof hashlock !== 'string' || hashlock.trim() === '') {
    const errorMsg = "Invalid 'hashlock' parameter provided. Must be a non-empty string.";
    console.error("Error in deriveCommitmentB:", errorMsg, "Received:", hashlock);
    throw new Error(errorMsg);
  }

  const bb = await Barretenberg.new();

  try {

    console.log("bob public keys in reconstruct commitment", publicKeyBob)
    console.log("private key alice in reconstruct commitment", secretKeyAlice);
    // 1. Convert inputs from strings to BigInt/Fr
    const bobPubKey = [
      BigInt(publicKeyBob[0]),
      BigInt(publicKeyBob[1]),
    ];
    const bobPubKeyPoint: [bigint, bigint] = [
      bobPubKey[0],
      bobPubKey[1],
    ];
    const secretKeyHex = convertToHex(secretKeyAlice)
    console.log(" secret key hex", secretKeyHex)
    const aliceSecretKeyBigInt = BigInt(secretKeyHex);
    
    // Hash the hashlock
    const hashlock_fr = Fr.fromString(hashlock);
    const haslock_hash_fr = await bb.poseidon2Hash([hashlock_fr]);

    console.log("Counterparty (Bob) Public Keys:", publicKeyBob);
    console.log("Input Hashlock (from Alice):", hashlock);

    // 2. Calculate shared secret
    // shared_secret = mulPointEscalar(Bob's_PK, Alice's_SK)
    // This produces the *exact same* shared secret as (Alice's_PK, Bob's_SK)
    const shared_secret = mulPointEscalar(
      bobPubKeyPoint,
      aliceSecretKeyBigInt
    );
    const shared_secret_x = shared_secret[0];
    console.log("Shared Secret X Coordinate (derived by Alice):", shared_secret_x.toString());

    // 3. Convert shared secret to Fr
    const shared_secret_x_fr = new Fr(shared_secret_x);

    // 4. Calculate Commitment B
    // This logic matches generateCommitmentB
    // derivedCommitmentB_fr = poseidon2Hash(H(hashlock), shared_secret_x)
    const derivedCommitmentB_fr = await bb.poseidon2Hash([
      haslock_hash_fr,
      shared_secret_x_fr,
    ]);
    console.log("Derived Commitment B (Fr):", derivedCommitmentB_fr.toString());

    // 5. Return commitment string
    return { commitment: derivedCommitmentB_fr.toString() };
    
  } catch (error) {
    console.error("Error deriving commitment B:", error);
    throw error;
  } finally {
    // 6. Clean up Barretenberg instance
    await bb.destroy();
  }
}

function convertToHex(str: string) {
    var hex = '';
    for(var i=0;i<str.length;i++) {
        hex += ''+str.charCodeAt(i).toString(16);
    }
    return hex;
}