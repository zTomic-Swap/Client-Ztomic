import { Barretenberg, Fr } from "@aztec/bb.js";
import { Base8, mulPointEscalar } from "@zk-kit/baby-jubjub";

/**
 * Derives Commitment B from Alice's perspective.
 * This function calculates the same commitment as generateCommitmentB,
 * but uses Alice's secret key and Bob's public key.
 *
 * @param publicKeyBob - Bob's (the counterparty's) public key as [x, y] coordinate strings.
 * @param secretKeyAlice - Alice's (the party's) secret key as a hex or decimal string.
 * @param hashlock - The hashlock string originally generated by Alice (from createCommitmentA).
 * @returns A promise that resolves to an object containing Commitment B's string.
 */
export async function deriveCommitmentB(
  publicKeyBob: [string, string], // Bob's Public Key
  secretKeyAlice: string, // Alice's Secret Key
  hashlock: string // Hashlock from createCommitmentA
): Promise<{ commitment: string }> {
  console.log("\n--- deriveCommitmentB: Start ---");
  console.log("deriveCommitmentB: Input publicKeyBob:", publicKeyBob);
  console.log("deriveCommitmentB: Input secretKeyAlice:", secretKeyAlice);
  console.log("deriveCommitmentB: Input hashlock:", hashlock);

  // Guard clause to check for valid hashlock string.
  if (!hashlock || typeof hashlock !== "string" || hashlock.trim() === "") {
    const errorMsg =
      "Invalid 'hashlock' parameter provided. Must be a non-empty string.";
    console.error(
      "Error in deriveCommitmentB:",
      errorMsg,
      "Received:",
      hashlock
    );
    throw new Error(errorMsg);
  }

  const bb = await Barretenberg.new();
  console.log("deriveCommitmentB: Barretenberg instance created.");

  try {
    console.log("bob public keys in reconstruct commitment", publicKeyBob); // Original log
    console.log(
      "private key alice in reconstruct commitment",
      secretKeyAlice
    ); // Original log

    // 1. Convert inputs from strings to BigInt/Fr
    const bobPubKey = [
      BigInt(publicKeyBob[0]),
      BigInt(publicKeyBob[1]),
    ];
    const bobPubKeyPoint: [bigint, bigint] = [
      bobPubKey[0],
      bobPubKey[1],
    ];
    console.log(
      "deriveCommitmentB: bobPubKeyPoint:",
      bobPubKeyPoint.map((v) => v.toString())
    );

    // --- FIXED ---
    console.log("deriveCommitmentB: secret key string (Alice):", secretKeyAlice);
    const aliceSecretKeyBigInt = BigInt(secretKeyAlice);
    // --- END FIX ---

    console.log(
      "deriveCommitmentB: aliceSecretKeyBigInt:",
      aliceSecretKeyBigInt.toString()
    );

    // Hash the hashlock
    const hashlock_fr = Fr.fromString(hashlock);
    console.log("deriveCommitmentB: hashlock_fr:", hashlock_fr.toString());

    const haslock_hash_fr = await bb.poseidon2Hash([hashlock_fr]);
    console.log(
      "deriveCommitmentB: haslock_hash_fr (H(hashlock)):",
      haslock_hash_fr.toString()
    );

    console.log("Counterparty (Bob) Public Keys:", publicKeyBob); // Original log
    console.log("Input Hashlock (from Alice):", hashlock); // Original log

    // 2. Calculate shared secret
    // shared_secret = mulPointEscalar(Bob's_PK, Alice's_SK)
    // This produces the *exact same* shared secret as (Alice's_PK, Bob's_SK)
    const shared_secret = mulPointEscalar(
      bobPubKeyPoint,
      aliceSecretKeyBigInt
    );
    console.log(
      "deriveCommitmentB: shared_secret [x, y]:",
      shared_secret.map((v) => v.toString())
    );

    const shared_secret_x = shared_secret[0];
    console.log(
      "Shared Secret X Coordinate (derived by Alice):",
      shared_secret_x.toString()
    ); // Original log

    // 3. Convert shared secret to Fr
    const shared_secret_x_fr = new Fr(shared_secret_x);
    console.log(
      "deriveCommitmentB: shared_secret_x_fr:",
      shared_secret_x_fr.toString()
    );

    // 4. Calculate Commitment B
    // This logic matches generateCommitmentB
    // derivedCommitmentB_fr = poseidon2Hash(H(hashlock), shared_secret_x)
    const derivedCommitmentB_fr = await bb.poseidon2Hash([
      haslock_hash_fr,
      shared_secret_x_fr,
    ]);
    console.log("Derived Commitment B (Fr):", derivedCommitmentB_fr.toString()); // Original log

    const commitmentString = derivedCommitmentB_fr.toString();
    console.log("deriveCommitmentB: Returning commitment:", commitmentString);

    // 5. Return commitment string
    return { commitment: commitmentString };
  } catch (error) {
    console.error("Error deriving commitment B:", error);
    throw error;
  } finally {
    // 6. Clean up Barretenberg instance
    await bb.destroy();
    console.log("deriveCommitmentB: Barretenberg instance destroyed.");
    console.log("--- deriveCommitmentB: End ---");
  }
}

// --- FIXED ---
// Deleted convertToHex function
// --- END FIX ---